Demystifying Microservices
1. In traditional layered web applications,
   layers are physically spreadable,
   where as modules within a layer are hardwired.

2. in Microservices, the above mentioned hardwired modules are separated

3. principles of microservices
  3.1 single responsibility per service
  3.2 microservices are autonomous
      Note:
        one of the major differences between microservices and SOA is in their level of autonomy.
        while most SOA implementations provide service-level abstraction,
        microservices go further and abstract the realization and execution environment.

4. Jenkins is a CI tool

5. Scale Cube
    Scaling the x axis by horizontally cloning the application
    Scaling the y axis by splitting different functionality
    Scaling the z axis by partitioning or sharding the data

6. Microservices are one of the key enablers of DevOps.
   DevOps is widely adopted as a practice in many enterprises,
   primarily to increase the speed of delivery and agility.

7. In the cloud,
   the infrastructure is transparent to the application.
   and especially, the physical IP address cannot be assumed

8. Cloud Native
    a term used for developing applications that can work efficiently in a cloud environment
    understanding the cloud behaviors such as elasticity, utilization based charging, fail aware, etc.

9. Twelve-Factor App
    is a methodology describing the characteristics expected from modern cloud-ready applications.
  9.1 a single code base
  9.2 bundling dependencies
        all applications should bundle their dependencies along with the application bundle.
  9.3 externalizing configurations
  9.4 backing services are addressable
  9.5 Isolation between build, release and run
  9.6 Stateless, shared nothing processes
        If there is any requirement to store a state,
        it should be done with a backing database or in an in-memory cache
  9.7 exposing services through port bindings
        application does not depend on the external servers,
        instead, they embed server inside themselves.
        microservices embed service listeners as a part of the service itself
  9.8 concurrency to scale out
  9.9 disposability with minimal overhead
  9.10 development and production parity
        keep development and production environments as identical as possible.
  9.11 externalizing logs
        in order to avoid local I/O bottleneck,
        the recommended approach is to ship logs to a central repository by tapping the logback appenders
        and write to one of the shippers' endpoints.
  9.12 package admin processes
        use the same release bundle as well as an identical environment for both application services and admin tasks.

Building Microservices with Spring Boot
1. @RestController = @Controller + @ResponseBody

2. In stead of a code generator,
   Spring Boot only autoconfigures build files.

3. Spring Boot also enables microservices' development by packaging all the required runtime dependencies in a fat executabl JAR FILE.

4. @SpringBootApplication = @Configuration + @EnableAutoConfiguration + @ComponentScan

5. There are number of tools available to test RESTful services, such as
   Postman, Advance REST client, SOAP UI, Paw, etc.

6. curl command can be used to visit an URL

7. In tests,
   @WebIntegrationTest annotation ensures that the tests are fired against a fully up-and-running server.
   @WebIntegrationTest = @WebAppConfiguration + @IntegrationTest

8. RestTemplate
    is used to all the RESTful service,
    it is a utility class that abstracts the lower level details of the HTTP client.

9.  Spring Initializr
      a drop-in replacement for the STS project wizard,
      and provides a web UI to configure and generate a Spring Boot project.

10. HATEOAS
      Hypertext As The Engine Of Application State
      It is a REST service pattern in which navigation links are provided as part of the payload metadata.
      The client application determines the state and follows the transition URLs provided as part of the state.

11. HAL
      Hypertext Application Language
      HAL browser is a handy API browser for hal+json  data.
      HAL is a format based on JSON that establishes conventions to represent hyperlinks between resources.
      HAL helps APIs be more explorable and discoverable.

12. Autoconfiguration,
      favors convention over configuration
      it uses "*AutoConfiguration" lexical pattern,
      where * represents the library.

13. Run the application with '--debug' to see the autoconfiguration report.

14. securing Spring Boot applications with OAuth2
      firstly, you need to include the OAuth2 dependency
  14.1 @EnableAuthorizationSever,
        creates an authorization server with an in-memory repository to store client tokens
        and provide clients with a username, password, client ID and secret.
  14.2 @EnableResourceServer,
        used to access the tokens.
        This enables a spring security filter that is authenticated via an incoming OAuth2 token

15. @CrossOrigin
      enables CORS (Cross-Origin Resource Sharing)

16. @Lazy
      beans annotated with @Lazy will be initialized only when the need arises.
      it helps to increase the boot startup time.

17. communication between microserviceA and microserviceB should be though "Messaging system"
    this is done by injecting a "Sender" in microsrviceA and a "Receiver" in microserviceB
    and let the "Sender" and "Receiver" talk to the "Middleware"

18. Once the application is annotated with @EnableSwagger2,
    you can visit http://localhost:8080/swagger-ui.html
    to visit the Swagger log

Applying Microservices Concepts
1. bounded context:
    DDD (Domain-driven design) defines the concept of a bounded context.
    a bounded context is a subdomain or subsystem of a larger domain or system that is responsible for performing a particular function.

2. One of the key characteristics of microservices is its support for polyglot architecture.

3. CQRS
    Command Query Responsibility Segregation
    It allows browser clients to send requests to services hosted on different domains.

4. Ensure that transaction boundaries are not stretched across microservices.
   A first class microservice will react upon receiving an event as an input,
   execute a number of internal functions,
   and finally send out another event.

5. Communication styles
  5.1 synchronous style (request-response)
    5.1.1 advantage
            there is no shared state or object
            no other infrastructure dependencies results in fewer overheads
            in case of error handling,
            error will be propagated back to the caller immediately,
            leaving the system in a consistent state,
            without compromising data integrity
    5.1.2 disadvantage
            has scalability limitations
            add hard dependencies between microservices
            many of the failure scenarios have to be handled using timeouts and loops
  5.2 asynchronous style (fire and forget)
    5.2.1 advantage
            services are independent,
            provides higher level of scalability
    5.2.2 disadvantage
            has a dependency to an external messaging server.
            It is complex to handle the fault tolerance of a messaging server.

6. ESB
    Enterprise Service Buss,
    it is found in legacy system architectures,
    but not in microservices

  iPaaS (Integration Platform as a Service)
    the next generation application integration platform.
    In typical deployments, iPaaS invokes API gateways to access microservices

7. (i)BPM
    (Intelligent) Business Process Management

8. Database level segregation is highly demanded.
   even in services have only a few tables,
   it may not be worth investing a full instance of a database,
   a schema level segregation is good enough to start with

9. Transaction boundaries
    It is appropriate to define transaction boundaries within the microsystem using local transactions.
    However, distributed global transactions should be avoided in the microservices context.

10. Eventual consistency is a better option than distributed transactions than span across multiple microservices.
    A classical problem is that of the last room selling scenario in a hotel booking case.
    What if there is only one room left, and there are multiple customers booking this single available room?
    A business model change sometimes make this scenario less impactful.
    We could set an "under booking profile",
    where the actual number of bookable rooms can go below the actual number of rooms (say, bookable = available - 3) in anticipation of cancellations.
    Anything in this range will be accepted as "subject to confirmation",
    and customers will be charged only if payment is confirmed.
    Bookings will be confirmed in a set time window (synchronous).

11. Service endpoint design consideration
      service design has two key elements: contract design and protocol design
  11.1 contract design principles
        KISS (Keep It Simple Stupid)
        YAGNI (You Ain't Gonna Need It)
        CDC (Consumer Driven Contract)
  11.2 protocol design
        The HTTP/REST/JSON protocol stack makes building interoperable system very easy and friendly.
        HATEOS is one of the design patterns emerging for designing progressive rendering and self-service navifations.
        If the service response times are stringent,
        then we may choose alternative protocols such as Avro, Protocol Buffers, or Thrift.

12. since microservices should be autonomous,
    there is a trade-off between adding a dependency versus code duplication

13. API gateway
      it is a UI service,
      which acts as a proxy to the backend.
      exposing a set of consumer-specific APIs.

14. Cross origin request
  14.1 one approach is to enable all microservices to allow cross origin requests (By using CROS)
  14.2 a second approach is to use an API gateway as a single trusted domain for the clients

15. With microservics, it is difficult to handle cross-table search, to solve this problem
  15.1 one approach is to use pre-aggregation to cache the desired data in advance,
       this will result in data duplication
  15.2 another approach is to use "batch query",
       this approach just reduce the query times

16. Service endpoints and communication protocols
  16.1 Synchronous:
        based on REST/JSOON or any other protocols such as Avro, Thrift, Protocol Buffers, etc.
  16.2 Asynchronous:
        Spring Cloud Streams backed by RabbitMQ, other messaging server, or other messaging style implementations such as ZeroMQ

17. Cluster control and provisioning:
      Once we have a large number of containers or virtual machines,
      it is hard to manage and maintain them automatically.
      Cluster control tools provides a uniform operating environment on top of the containers,
      and share the available capacity across multiple services.
      Apache Mesos and Kubernetes are examples of cluster control systems

18. Service registry
      A service registry provides a runtime environment for services to automatically publish their availability at runtime.
      A registry will be good source of information to understand the services topology at any point.
      Eureka from Spring Cloud, Zookeeper, and Etcd are some of the service registry tools available.

19. Data Lake
      used to combine data stored in different microservices,
      and perform near real-time analytics.
      Data integration tools like Spring Cloud Data Flow, Flume, and Kafka are used to consume data.
      HDFS, Cassandra, and the like are used for storing data.

Microservices Evolution - A Case Study
1. dependencies could be query-based or event-based
   event-based is better for scalable systems.

2. Payment is typically a disconnected function due to the nature of security constraints such as PCIDSS-like standards
   The most obvious way to capture a payment is to redirect a browser to a payment page hosted in the payment service

3. SSO
    Single sign-on

4. 
