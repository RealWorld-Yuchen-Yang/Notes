Understanding object/relational persistence
1. Relational database product (Relational database management system with SQL-based application programming interfaces):
    DBMS (DataBase Management System)

2. Two paradigms:
    Object Modeling, object-oriented programming
    Relational Modeling, SQL
    These two paradigms have the following mismatches
    2.1 granularity, in terms of contained objects
    2.2 subtypes, how to map subtype, when there is only one foreign key
    2.3 identity, how to determine two entities are equal

3. UDT, User Defined data Types

4. Identity of a database row is expressed as
   a comparison of primary key values

5. surrogate key, is a primary key column with no meaning to the application user
                  it  is not presented to the application user,
                  but only used to identify data inside the application

6. lazy loading, retrieving data on demand only.
                 in java, fetching the data of associated instances only when the association is first accessed
                 in persistence context, it is inefficient, because it requires executing one statement for each node or collection of the object network that is accessed.

Introducing Hibernate (Hibernate is a middleware (persistence) framework)
1. Hibernate is a JPA standard's implementation who not only an **ORM service**,
   but also a collection of data management tools extending well beyond ORM.
  1.1 Hibernate ORM, consists of
      * a core
      * base service for persistence with SQL database
      * a native proprietary API
  1.2 Hibernate EntityManager,
      Hibernate's implementation of the standard Java Persistence APIs,
      it is an optional module you can stack on top of Hibernate ORM
      Hibernate's native features are a superset of the JPA persistence features in every respect
  1.3 Hibernate Validator,
      provides declarative validation for your domain model
  1.4 Hibernate Envers,
      like version control systems
      Envers is dedicated to audit logging and keeping multiple versions of data in SQL database
      This helps you add history and audit trails to your application
  1.5 Hibernate Search,
      Hibernate Search keeps an index of your domain model data up to date in an Apache Lucence database
  1.6 Hibernate OGM
      OGM, object/grid mapper
      It provides JPA support for NoSQL solutions

2. Persistence Unit,
   Your starting point in JPA is the persistence unit.
   It is a pairing of domain model class mappings with a database connection.

3. standard configuration file for persistence unit is located the classpath,
   in META-INF/persistence.xml

4. Standard or vendor-specific options can be set as properties on a persistence unit.
   * standard properties, name should be prefixed with javax.persistence
   * Hibernate's settings, name should be prefixed with hibernate

5. To log SQL,
   in persistence.xml, set the following properties to true
   * hibernate.format_sql
   * hibernate.use_sql_comments

6. Basic mapping configuration of classes to be persisted (annotation-based)
  6.1 @Entity, class annotation to the domain model
               every persistent entity class must have at least the @Entity annotation.
               Hibernate maps this class to a table in the database with the same name as class name, but all uppercase characters
               e.g. Java class "Message" is mapped to database table "MESSAGE"
  6.2 @Id, attribute annotation
           every persistent entity class must have an identifier attribute annotated with @Id
           Hibernate maps this attribute to a column named ID
           Note, id property defined in the persistence class can be any type,
                 but usually it is defined as "long"
  6.3 @GeneratedValue, attribute annotation
                       it is a attribute value generation strategy
                       usually, it is used to annotate Ids
  6.4 Persistence class should conform the JavaBean convention
      6.4.1 has no parameter constructor
      6.4.2 naming of property follows getter/setter naming,
            what is more, the mapped column name in the database is the same as properties,
            but with all uppercase characters

7. you can use the persistent class in any execution context,
   no special container is needed

8. the alternative way of defining mapping other than annotation
   is by using xml,
   and in the following locations
   * orm.xml, JPA object relation mapping file
   * hbm.xml, Hibernate native object relation mapping file

9. Storing and loading messages
  9.1 First you need an **EntityManagerFactory** to talk to your database.
      This API represents your persistence unit
  9.2 transaction starts and ends with explicit declarations
    * UserTransaction's **begin()** method declares the starting point of the transaction
    * UserTransaction's **commit()** method declares the end point of the transaction
  9.3 Inside the transaction boundary,
      we use the entityManager (which is created by the EntityManagerFactory) to persist object instances
      and to do database queries
  9.4 finally after the transaction is committed,
      we close the entityManager

10. JPQL, Java Persistence Query Language

11. The Hibernate counterpart of the EntityManagerFactory is the SessionFactory
    and the EntityManagerFactory's configuration option's counterpart this the Session

Domain models and metadata
1. Cross-cutting concerns
  It is often implemented by framework code.
  Including logging, authorization, transaction demarcation, security, concurrency, remoteness

2. For the starting point of modeling, we can start either from the domain model, or from the database table
   there is only slight differences between the two starting points,
   and eventually, they will be mapped to each other

3. The main concern of defining the database schema is to keep the integrity of the data

4. Working with fine-grained and rich domain models is a major Hibernate objective.
   In general, using fine-grained objects means more classes (Domain Entity) than tables

5. When storing a collection of objects, sometimes we would like the stored object to have some sequence,
   However it does not mean that we need to maintain such sequence in the database.
   Data integrity is not affected the sequence
   To make the sequence behavior flexible,
   we can always restore it when doing data retrieving

6. Hibernate recognizes constraints on persistent domain model classes
   and triggers validation before database insert or update operations.

7. A class mapping in a Hibernate XML document is a "complete" mapping,
   which means that any other mapping metadata for that class,
   whether in annotations or JPA XML files,
   will trigger a "duplicate mapping" error on startup.

8. The persistent classes only depend on JPA at compile time.
******************************************************************
No book notes from chapter 4, the following are Java Brains Notes
******************************************************************
1. In order to let Hibernate persist an object, we should
  1.1 mark the class as @Entity
  1.2 Offer an id, usually a surrogate key
    Note: different type of keys
      1. candidate keys, a class can have multiple candidate keys, each of them can be used as a distinguisher of the class object
      2. primary key, one of the candidate keys chosen to be the to be used identifier of the class
                      primary key can be a single key, or a composite key, can be natural key or a surrogate key
                      2.1 natural key, one of the business properties in Java, chosen to be the primary key
                      2.2 surrogate key, a synthetic primary key, solely used in database to identify the object, has no business meaning in Java Class

2. Using the Hibernate API
  2.1 Create a session factory, by using Hibernate's configuration file
      Note: the sessionFactory object is often shared among classes and even among layers
  2.2 Create a session from the session factory
      Session session = sessionFactory.openSession()
  2.3 Use the session to save model objects
      session.save(OBJ_TO_BE_SAVED)
      session.getTransaction().commit()
  2.4 close the session
      session.close()
  Note: the database table is automatically created by Hibernate, there is no need to manually create the database table

3. Hibernate default recreate the database schema every time the application starts
   If we want to persist the data for longer time
   we can configure hibernate.cfg.xml's
  <property name="hbm2ddl.auto">update</property>

4. Class level annotations:
  4.1 @Entity, configure the whole entity class
  4.2 @Table, only used to configure the database table corresponding to the entity
  4.3 @Embeddable, mark the class as a value type, counter to entity type,
                   once its instance appears as a property of some other object,
                   the persistence strategy is always embed the current object

5. property level annotations:
  5.1 @Id, used to mark identifiers, usually a surrogate with Long type
      @GeneratedValue, is used to mark @Id, specifying the strategy how Hibernate generate the surrogate key
  5.2 @Column, can be used to configure the database table column
  5.3 @Collection, marked on collection-typed properties. so that Hibernate will store the collection property accordingly
  5.4 @Basic
  5.5 @Transient, used to tell Hibernate whether to save the corresponding property or not
  5.6 @Temporal, used to configure Date and Time related properties, like Date
  5.6 @Lob, used to mark String/byte[] typed properties, to indicate their size can be larger than default String's Max size 255
        Hibernate will figure it out by itself, whether the Lob is blob or clob
  5.7 @Embedeed, to mark the current value property as a embedded type,
                 after this marking, the current property will be considered a sub-object  and dissected
                 each property of the Embedded object will appear with its master table
  5.8 @AttributeOverride, used to reconfigure the current property object
      e.g. @AttributeOverride(name="ORIGINAL_NAME"), column=@Column(name="NEW_NAME")
      @AttributeOverrides, if multiple @AttriubteOverride need to be specified,
                           @AttributeOverrides is used to group these @AttributeOverride annotations
  5.9 @EmbeddedId, used to mark value-typed Id
  5.10 @ElementCollection, is used to mark collection objects
                           the collection property is stored in a separate table,
                           default name is prefixed with containing class's classname
                           @ElementCollection has "fetch" property, which can be used to specify fetching strategies: EAGER/LAZY
       Note: collection object's declaration type should be the conforming interface,
             instead of the actual implementation class
             Also, the collection table stores the containing class's primary key as a foreign key to reference the parent
        @JoinTable, used to mark @ElementCollection, to perform join with other table, especially the parent
        @CollectionId, used to mark @ElementCollection,
                       It is a Hibernate specific annotation,
                       and is used to generate the primary key for the generated collection table.

6. get object (Actually is the Hibernate maintained object's corresponding proxy object)
  session.get(OBJECT.class, PRIMARY_KEY_VALUE)
  Note: the default "primary key" is the Id

7. when using sessionFactory to get objects,
   the returned object is not the desired class,
   but the default class's proxy (which inherits the desired class, of course)
   the default object fetching strategy is lazy-fetching, only the first level properties are fetch at the first time
   other deeper level properties are fetch when they are actually called/used.
   if session is closed before the deeper level objects are to be called,
   the fetch will fail.
   An alternative fetching-strategy is eager-fetching, which fetches all the properties at the first time

8. advanced association mapping #######java brains tutorial 13
  8.1 one-to-one mapping
  8.2 one-to-many mapping
  8.3 many-to-many mapping

9. Inheritance mapping strategies
  9.1 single table strategy
  9.2 table per class strategy
  9.3 joined strategy
