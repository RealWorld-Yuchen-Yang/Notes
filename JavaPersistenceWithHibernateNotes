Understanding object/relational persistence
1. Relational database product (Relational database management system with SQL-based application programming interfaces):
    DBMS (DataBase Management System)

2. Two paradigms:
    Object Modeling, object-oriented programming
    Relational Modeling, SQL
    These two paradigms have the following mismatches
    2.1 granularity, in terms of contained objects
    2.2 subtypes, how to map subtype, when there is only one foreign key
    2.3 identity, how to determine two entities are equal

3. UDT, User Defined data Types

4. Identity of a database row is expressed as
   a comparison of primary key values

5. surrogate key, is a primary key column with no meaning to the application user
                  it  is not presented to the application user,
                  but only used to identify data inside the application

6. lazy loading, retrieving data on demand only.
                 in java, fetching the data of associated instances only when the association is first accessed
                 in persistence context, it is inefficient, because it requires executing one statement for each node or collection of the object network that is accessed.

Introducing Hibernate (Hibernate is a middleware (persistence) framework)
1. Hibernate is a JPA standard's implementation who not only an **ORM service**,
   but also a collection of data management tools extending well beyond ORM.
  1.1 Hibernate ORM, consists of
      * a core
      * base service for persistence with SQL database
      * a native proprietary API
  1.2 Hibernate EntityManager,
      Hibernate's implementation of the standard Java Persistence APIs,
      it is an optional module you can stack on top of Hibernate ORM
      Hibernate's native features are a superset of the JPA persistence features in every respect
  1.3 Hibernate Validator,
      provides declarative validation for your domain model
  1.4 Hibernate Envers,
      like version control systems
      Envers is dedicated to audit logging and keeping multiple versions of data in SQL database
      This helps you add history and audit trails to your application
  1.5 Hibernate Search,
      Hibernate Search keeps an index of your domain model data up to date in an Apache Lucence database
  1.6 Hibernate OGM
      OGM, object/grid mapper
      It provides JPA support for NoSQL solutions

2. Persistence Unit,
   Your starting point in JPA is the persistence unit.
   It is a pairing of domain model class mappings with a database connection.

3. standard configuration file for persistence unit is located the classpath,
   in META-INF/persistence.xml

4. Standard or vendor-specific options can be set as properties on a persistence unit.
   * standard properties, name should be prefixed with javax.persistence
   * Hibernate's settings, name should be prefixed with hibernate

5. To log SQL,
   in persistence.xml, set the following properties to true
   * hibernate.format_sql
   * hibernate.use_sql_comments

6. Basic mapping configuration of classes to be persisted (annotation-based)
  6.1 @Entity, class annotation to the domain model
               every persistent entity class must have at least the @Entity annotation.
               Hibernate maps this class to a table in the database with the same name as class name, but all uppercase characters
               e.g. Java class "Message" is mapped to database table "MESSAGE"
  6.2 @Id, attribute annotation
           every persistent entity class must have an identifier attribute annotated with @Id
           Hibernate maps this attribute to a column named ID
           Note, id property defined in the persistence class can be any type,
                 but usually it is defined as "long"
  6.3 @GeneratedValue, attribute annotation
                       it is a attribute value generation strategy
                       usually, it is used to annotate Ids
  6.4 Persistence class should conform the JavaBean convention
      6.4.1 has no parameter constructor
      6.4.2 naming of property follows getter/setter naming,
            what is more, the mapped column name in the database is the same as properties,
            but with all uppercase characters

7. you can use the persistent class in any execution context,
   no special container is needed

8. the alternative way of defining mapping other than annotation
   is by using xml,
   and in the following locations
   * orm.xml, JPA object relation mapping file
   * hbm.xml, Hibernate native object relation mapping file

9. Storing and loading messages
  9.1 First you need an **EntityManagerFactory** to talk to your database.
      This API represents your persistence unit
  9.2 transaction starts and ends with explicit declarations
    * UserTransaction's **begin()** method declares the starting point of the transaction
    * UserTransaction's **commit()** method declares the end point of the transaction
  9.3 Inside the transaction boundary,
      we use the entityManager (which is created by the EntityManagerFactory) to persist object instances
      and to do database queries
  9.4 finally after the transaction is committed,
      we close the entityManager

10. JPQL, Java Persistence Query Language

11. The Hibernate counterpart of the EntityManagerFactory is the SessionFactory
    and the EntityManagerFactory's configuration option's counterpart this the Session

Domain models and metadata
1. Cross-cutting concerns
  It is often implemented by framework code.
  Including logging, authorization, transaction demarcation, security, concurrency, remoteness

2. For the starting point of modeling, we can start either from the domain model, or from the database table
   there is only slight differences between the two starting points,
   and eventually, they will be mapped to each other

3. The main concern of defining the database schema is to keep the integrity of the data

4. Working with fine-grained and rich domain models is a major Hibernate objective.
   In general, using fine-grained objects means more classes (Domain Entity) than tables

5. When storing a collection of objects, sometimes we would like the stored object to have some sequence,
   However it does not mean that we need to maintain such sequence in the database.
   Data integrity is not affected the sequence
   To make the sequence behavior flexible,
   we can always restore it when doing data retrieving

6. Hibernate recognizes constraints on persistent domain model classes
   and triggers validation before database insert or update operations.

7. A class mapping in a Hibernate XML document is a "complete" mapping,
   which means that any other mapping metadata for that class,
   whether in annotations or JPA XML files,
   will trigger a "duplicate mapping" error on startup.

8. The persistent classes only depend on JPA at compile time.

******************************************************************
No book notes from chapter 4, the following are Java Brains Notes
******************************************************************

1. In order to let Hibernate persist an object, we should
  1.1 mark the class as @Entity
  1.2 Offer an id, usually a surrogate key
    Note: different type of keys
      1. candidate keys, a class can have multiple candidate keys, each of them can be used as a distinguisher of the class object
      2. primary key, one of the candidate keys chosen to be the to be used identifier of the class
                      primary key can be a single key, or a composite key, can be natural key or a surrogate key
                      2.1 natural key, one of the business properties in Java, chosen to be the primary key
                      2.2 surrogate key, a synthetic primary key, solely used in database to identify the object, has no business meaning in Java Class

2. Using the Hibernate API
  2.1 Create a session factory, by using Hibernate's configuration file
      Note: the sessionFactory object is often shared among classes and even among layers
  2.2 Create a session from the session factory
      Session session = sessionFactory.openSession()
  2.3 Use the session to save model objects
      session.save(OBJ_TO_BE_SAVED)
      session.getTransaction().commit()
  2.4 close the session
      session.close()
  Note: the database table is automatically created by Hibernate, there is no need to manually create the database table

3. Hibernate default recreate the database schema every time the application starts
   If we want to persist the data for longer time
   we can configure hibernate.cfg.xml's
  <property name="hbm2ddl.auto">update</property>

4. Class level annotations:
  4.1 @Entity, configure the whole entity class
  4.2 @Table, only used to configure the database table corresponding to the entity
  4.3 @Embeddable, mark the class as a value type, counter to entity type,
                   once its instance appears as a property of some other object,
                   the persistence strategy is always embed the current object
  4.4 @Inheritance, used to configure inheritance mapping
      @DiscriminatorColumn, on ParentClass, used to configure DiscriminatorColumn of inheritance
      @DiscriminatorValue, use to specify the DiscriminatorValue
  4.5 @NamedQuery(name="NAME", query="HQL_QUERY"),
      @NamedNativeQuery(name="NAME", query="SQL_QUERY", resultClass=RESULT.class),


5. property level annotations:
  5.1 @Id, used to mark identifiers, usually a surrogate with Long type
      @GeneratedValue, is used to mark @Id, specifying the strategy how Hibernate generate the surrogate key
  5.2 @Column, can be used to configure the database table column
  5.3 @Collection, marked on collection-typed properties. so that Hibernate will store the collection property accordingly
  5.4 @Basic
  5.5 @Transient, used to tell Hibernate whether to save the corresponding property or not
  5.6 @Temporal, used to configure Date and Time related properties, like Date
  5.6 @Lob, used to mark String/byte[] typed properties, to indicate their size can be larger than default String's Max size 255
        Hibernate will figure it out by itself, whether the Lob is blob or clob
  5.7 @Embedeed, to mark the current value property as a embedded type,
                 after this marking, the current property will be considered a sub-object  and dissected
                 each property of the Embedded object will appear with its master table
  5.8 @AttributeOverride, used to reconfigure the current property object
      e.g. @AttributeOverride(name="ORIGINAL_NAME"), column=@Column(name="NEW_NAME")
      @AttributeOverrides, if multiple @AttriubteOverride need to be specified,
                           @AttributeOverrides is used to group these @AttributeOverride annotations
  5.9 @EmbeddedId, used to mark value-typed Id
  5.10 @ElementCollection, is used to mark collection objects
                           the collection property is stored in a separate table,
                           default name is prefixed with containing class's classname
                           @ElementCollection has "fetch" property, which can be used to specify fetching strategies: EAGER/LAZY
       Note: collection object's declaration type should be the conforming interface,
             instead of the actual implementation class
             Also, the collection table stores the containing class's primary key as a foreign key to reference the parent
        @JoinTable, used to mark @ElementCollection, to perform join with other table, especially the parent
        @CollectionId, used to mark @ElementCollection,
                       It is a Hibernate specific annotation,
                       and is used to generate the primary key for the generated collection table.
  5.11 @OneToOne, used to mark entity associations
       @OneToMany
       @ManyToOne
       @ManyToMany
  5.12 @NotFound(action=NotFoundAction.IGNORE), used to mark the above association annotations
                                                specifying the IGNORE action, if the association is not yet established

6. get object (Actually is the Hibernate maintained object's corresponding proxy object)
  session.get(OBJECT.class, PRIMARY_KEY_VALUE)
  Note: the default "primary key" is the Id

7. when using sessionFactory to get objects,
   the returned object is not the desired class,
   but the default class's proxy (which inherits the desired class, of course)
   the default object fetching strategy is lazy-fetching, only the first level properties are fetch at the first time
   other deeper level properties are fetch when they are actually called/used.
   if session is closed before the deeper level objects are to be called,
   the fetch will fail.
   An alternative fetching-strategy is eager-fetching, which fetches all the properties at the first time

8. advanced association mapping: entity inside entity
   Note: the mapping is unidirectional PARENT_CLASS to CHILD|CHILDREN_PROPERTY
         if we would like to construct bidirectional association, we should annotate on both sides
         the association annotations can have "cascade" property,
         which let the user specify what to do with the subsequent entity when the current entity has been updated.
         so as to save the user's effort of manually update subsequent entity

  8.1 one-to-one mapping
    In the parent class, annotate the contained entity property with
    @OneToOne.

  8.2 one-to-many mapping
    In the parent class, annotate the contained entity collection property with
    @OneToMany
    After this Annotation, when doing persistence,
    an additional "association table" is created, containing the parent and children primary keys' combination

  8.3 many-to-one mapping
    Similar to one-to-many mapping,
    only the association's direction is inverse,
    this time the parent is the one with multiple instances.
    @ManyToOne

  8.4 bidirectional-one-to-many-and-many-to-one mapping in a joined table
    In one class, mark @OneToMany(mappedBy="OPPOSITE_TABLE_PROPERTY_NAME")
                  after this annotation,
                  we are expecting the other table will be specified as the joined table containing the association relationship
    In the other class, at the same time, mark @ManyToOne on the other entity property
                                               @JoinColumn("OPPOSITE_PROPERTY_NAME_IN_JOINED_TABLE")
    After this mapping, the bidirectional association is created in one joined table
                        so in total, instead of 3 tables, Hibernate will only generate 2 tables, one for each entity, association information only appears in one of them

  8.5 many-to-many mapping
      similar to one-to-many bidirectional mapping, we mark
      @ManyToMany on both classes' entity collection properties.
      In order to guide Hibernate to generate association on only one table,
      we need to add "mappedBy" argument on one of the @ManyToMany annotations,
      that is @ManyToMany(mappedBy="OPPOSITE_TABLE_PROPERTY_NAME")
      after this annotation, 3 tables in total will be created, 2 for entities, 1 for the joined association



9. Inheritance mapping strategies
    @Inheritance to configure inheritance behavior
      e.g. @Inheritance(strategy=InheritanceType.SINGLE_TABLE...)

    @DiscriminatorColumn
      e.g. @DiscriminatorColumn(
        name="NAME"
        discriminatorType=DiscriminatorType.XXX
      )

    @DiscriminatorValue, use to specify the DiscriminatorValue

  9.1 single table strategy:
        this is the default strategy of Hibernate,
        ("default", means only annotate the classes as @Entity, no additional annotation)
        map everything into the base class's table,
        additionally, add the string valued datatype (dtype) to each stored object instances
        this strategy will end up with many "holes" in the database table

  9.2 table per class strategy
      @Inheritance(strategy=Inheritance.TABLE_PER_CLASS), on the parent class
      no need to annotate the children classes other than @Entity
      behavior:
        children class will store all properties in itself's table
        (no matter whether they are declared directly in themselves or inherited)
      Downside of this strategy is there will be many data duplications in the database
      also, the child class table has no clue that who is its parent

  9.3 joined strategy
      @Inheritance(strategy=InheritanceType.JOINED), on the parent class
      behavior:
        all properties defined in a class will appear in its own class,
        except for duplications of "primary keys",
        duplicated primary keys will be used as foreign keys, when doing join table sql query on the child class,
        so as to get the whole information of the child class
      This is the best choice.

10. Hibernate Collections
  10.1 Bag semantic (allow duplication): List/ArrayList, etc.
  10.2 Bag semantic with ID (allow value duplication): List/ArrayList, etc.
  10.3 List semantic (allow duplication): List/ArrayList, etc.
  10.4 Set semantic (no duplication): set
  10.5 Map semantic: Map

11. Since there are many discrepancies between Java and relational data
    when storing objects into relational database,
    information like "association (due to the flat structure of relational table)" will be missed.
                     "inheritance"
    To compensate this, Hibernate will generate additional table to store the missing information

12. CRUD Operations
    session.save(OBJECT)
    session.get(OBJECT.CLASS, PRIMARY_KEY)
    session.update(OBJECT), (the "OBJECT" has to be "gotten" by the session previously)
    session.delete(OBJECT), delete() operation will transfer the object's state from "Persistent" to "Transient"

    Note: by default,
          we can still visit object's first level data outside the session,
          for the proxy object returned by the session contains first level data in them

13. Transient, Persistent and Detached Objects
  13.1 Transient object:
        Once the object has just been instantiated, but not yet saved by Hibernate

  13.2 Persistent object:
        Once the object is persisted by using Hibernate's session.save()
        Note:
              during the session,
              even if you do not specify the update operation,
              the changes of the persisted object will be updated automatically

  13.3 Detached object:
        After session.close(),
        objects "obtained from"/"saved into" session are detached.
        only cached data (like object's first level properties) can be accessed

14. @org.hibernate.annotation.Entity(selectBeforeUpdate=true),
    once we use this Hibernate specific annotation to mark the class
    when doing update,
    Hibernate will first do a select,
    only update if the instance of the class has been changed.
    This increases performance when change to the object is scarce, otherwise it will decrease performance.

15. HQL Query
  15.1 Should be performed inside Hibernate's session,
       very similar to SQL

  15.2 HQL is "object-centric",
       so query should be based on object and properties,
       instead of on tables and columns

  15.3 SQL query injection: inject "value" into sql queries, then you may get undesired results

  15.4 ParameterBinding in query context: bind values to parameters in your SQL queries
       Hibernate uses ParameterBinding to prevent SQL injection.
       Syntax:
          you can use '?' or ':PARAM_NAME' as place holders in the query string,
          and use the query object's set(INDEX or PARAM_NAME, VALUE) to supply values to the indexedParameterPlaceHolders

  15.5 @NamedQuery, named HQL queries
                    allows programmer define queries at the @Entity Level,
                    which groups queries in one place and makes maintaining queries easier
        syntax:
          declaration:
            @NamedQuery(name="NAME", query="HQL_QUERY"),
            Note: the naming convention can be ENTITY_NAME.action, which describes the query
          use:
            session.getNamedQuery(NAME)

       Note: you can also use named SQL queries by declaring queries as
             @NamedNativeQuery(name="NAME", query="SQL_QUERY", resultClass=RESULT.class),
             as can be seen, if we use SQL query, we need to explicit indicate Hibernate which result class should it hand back
