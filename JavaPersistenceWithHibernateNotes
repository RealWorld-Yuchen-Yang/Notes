Understanding object/relational persistence
1. Relational database product (Relational database management system with SQL-based application programming interfaces):
    DBMS (DataBase Management System)

2. Two paradigms:
    Object Modeling, object-oriented programming
    Relational Modeling, SQL
    These two paradigms have the following mismatches
    2.1 granularity, in terms of contained objects
    2.2 subtypes, how to map subtype, when there is only one foreign key
    2.3 identity, how to determine two entities are equal

3. UDT, User Defined data Types

4. Identity of a database row is expressed as
   a comparison of primary key values

5. surrogate key, is a primary key column with no meaning to the application user
                  it  is not presented to the application user,
                  but only used to identify data inside the application

6. lazy loading, retrieving data on demand only.
                 in java, fetching the data of associated instances only when the association is first accessed
                 in persistence context, it is inefficient, because it requires executing one statement for each node or collection of the object network that is accessed.

Introducing Hibernate (Hibernate is a middleware (persistence) framework)
1. Hibernate is a JPA standard's implementation who not only an **ORM service**,
   but also a collection of data management tools extending well beyond ORM.
  1.1 Hibernate ORM, consists of
      * a core
      * base service for persistence with SQL database
      * a native proprietary API
  1.2 Hibernate EntityManager,
      Hibernate's implementation of the standard Java Persistence APIs,
      it is an optional module you can stack on top of Hibernate ORM
      Hibernate's native features are a superset of the JPA persistence features in every respect
  1.3 Hibernate Validator,
      provides declarative validation for your domain model
  1.4 Hibernate Envers,
      like version control systems
      Envers is dedicated to audit logging and keeping multiple versions of data in SQL database
      This helps you add history and audit trails to your application
  1.5 Hibernate Search,
      Hibernate Search keeps an index of your domain model data up to date in an Apache Lucence database
  1.6 Hibernate OGM
      OGM, object/grid mapper
      It provides JPA support for NoSQL solutions

2. Persistence Unit,
   Your starting point in JPA is the persistence unit.
   It is a pairing of domain model class mappings with a database connection.

3. standard configuration file for persistence unit is located the classpath,
   in META-INF/persistence.xml

4. Standard or vendor-specific options can be set as properties on a persistence unit.
   * standard properties, name should be prefixed with javax.persistence
   * Hibernate's settings, name should be prefixed with hibernate

5. To log SQL,
   in persistence.xml, set the following properties to true
   * hibernate.format_sql
   * hibernate.use_sql_comments

6. Basic mapping configuration of classes to be persisted (annotation-based)
  6.1 @Entity, class annotation to the domain model
               every persistent entity class must have at least the @Entity annotation.
               Hibernate maps this class to a table in the database with the same name as class name, but all uppercase characters
               e.g. Java class "Message" is mapped to database table "MESSAGE"
  6.2 @Id, attribute annotation
           every persistent entity class must have an identifier attribute annotated with @Id
           Hibernate maps this attribute to a column named ID
           Note, id property defined in the persistence class can be any type,
                 but usually it is defined as "long"
  6.3 @GeneratedValue, attribute annotation
                       it is a attribute value generation strategy
                       usually, it is used to annotate Ids
  6.4 Persistence class should conform the JavaBean convention
      6.4.1 has no parameter constructor
      6.4.2 naming of property follows getter/setter naming,
            what is more, the mapped column name in the database is the same as properties,
            but with all uppercase characters

7. you can use the persistent class in any execution context,
   no special container is needed

8. the alternative way of defining mapping other than annotation
   is by using xml,
   and in the following locations
   * orm.xml, JPA object relation mapping file
   * hbm.xml, Hibernate native object relation mapping file

9. Storing and loading messages
  9.1 First you need an **EntityManagerFactory** to talk to your database.
      This API represents your persistence unit
  9.2 transaction starts and ends with explicit declarations
    * UserTransaction's **begin()** method declares the starting point of the transaction
    * UserTransaction's **commit()** method declares the end point of the transaction
  9.3 Inside the transaction boundary,
      we use the entityManager (which is created by the EntityManagerFactory) to persist object instances
      and to do database queries
  9.4 finally after the transaction is committed,
      we close the entityManager

10. JPQL, Java Persistence Query Language

11. The Hibernate counterpart of the EntityManagerFactory is the SessionFactory
    and the EntityManagerFactory's configuration option's counterpart this the Session

Domain models and metadata
1. Cross-cutting concerns
  It is often implemented by framework code.
  Including logging, authorization, transaction demarcation, security, concurrency, remoteness

2. For the starting point of modeling, we can start either from the domain model, or from the database table
   there is only slight differences between the two starting points,
   and eventually, they will be mapped to each other

3. The main concern of defining the database schema is to keep the integrity of the data

4. Working with fine-grained and rich domain models is a major Hibernate objective.
   In general, using fine-grained objects means more classes (Domain Entity) than tables

5. When storing a collection of objects, sometimes we would like the stored object to have some sequence,
   However it does not mean that we need to maintain such sequence in the database.
   Data integrity is not affected the sequence
   To make the sequence behavior flexible,
   we can always restore it when doing data retrieving

6. Hibernate recognizes constraints on persistent domain model classes
   and triggers validation before database insert or update operations.

7. A class mapping in a Hibernate XML document is a "complete" mapping,
   which means that any other mapping metadata for that class,
   whether in annotations or JPA XML files,
   will trigger a "duplicate mapping" error on startup.

8. The persistent classes only depend on JPA at compile time.

******************************************************************
No book notes from chapter 4-9
******************************************************************

Transactional data processing
Managing data
1. Entity instance states (JPA definition)
  1.1 Transient:
        transient instances created with "new" keyword,
        Hibernate doesn't provide any rollback functionality for transient instances
  1.2 Persistent:
        persistent entity instance has a representation in the database. (consistent with database)
  1.3 Removed:
        removed from the database.
        you should discard any references you may hold to it in the application after you finish working with it.
  1.4 Detached:
        stale data, removed from persistentContext
        modification of it will not reflect in its database representation.
        merge() detached objects can merge the changed stale data back to its persistent counterpart in the database

2. PersistentContext
  2.1 created at EntityManagerFactory#createEntityManager()
      closed at EntityManager#close()
      persistentContext defines the scope of the persistent context, demarcating the **unit of work**
  2.2 The persistent context acts first level cache,
      it remembers all entity instances you have handled in a particular unit of work
  2.3 changes made in a particular persistent context are already immediately visible to all other code executed inside that unit of work
      and its persistence context.

3. Rollback:
  If one of the INSERT or UPDATE statements (database operation) made when flushing fails,
  Hibernate causes a rollback of changes made to persistent instances in this transaction at the database level.
  But Hibernate doesn't roll back in-memory changes to persistent instances.
  That can be that Hibernate will not roll back changes after a persistent(), if commit failure occurs
  This is reasonable because a failure of a transaction is normally non-recoverable,
  and you have to discard (roll back) the failed persistence context and EntityManager immediately.

4. DML statements usually create locks in the database that are held until the transaction completes,
   so Hibernate keeps the lock duration in the database as short as possible by
   propagate state changes to the database as late as possible

5. Refreshing data:
  5.1 definition:
    If entity record is modified in the database after it is retrieved.
    by calling EntityManager#refresh(ENTITY) will update the application memory with the latest instance
    if the entity is deleted, EntityNotFoundException is to be thrown
  5.2 usage:
    usually no manual refresh() is needed.
    the best use case for refreshing is with an extended persistence context,
    which might span several request/response cycles and/or system transactions.

6. Replication
  You may need replication when you reconcile data entered into different databases.

7. Hibernate, as a JPA implementation, synchronize at the following times:
  7.1 When a joined JTA system transaction is committed
  7.2 Before a query is executed--query with javax.persistence.Query or the similar Hibernate API
  7.3 When the application calls flush() explicitly

8. You can at any time, while a transaction is in progress,
   force dirty checking and synchronization with database by calling EntityManager#flush()

9. in different persistenceContext, entities represented by the same database table may not be equal
   this may not be the desired behavior, so
   whenever you work with instances in detached state and you test them for equality (usually in hash-based collections),
   you need to supply your own implementation of the equals() and hashCode() method for your mapped entity class.

10. Implementing equality methods;
  10.1 when overriding equals method, we must override hashCode() as well.
       if two instances are equal, they must have the same hashCode(),
       (Note: on the contrary, if two instances' hashCode() are the same, they may not be equal, think of hashCode clashing)
  10.2 we should favor of business key equality over database identifier equality, the later may change if the entity to be persisted is in a collection
    10.2.1 business key: a property/some combination of properties,
                         that is unique for each instance with the same database identity
    10.2.2 business key is what the user thinks of as uniquely identifying a particular record (also have an unique constraint on the database column),
           whereas the surrogate key is what the application and database systems rely on.
  10.3 best practice can be found on p277 of the book

11. If you want to delete a detached instance,
    you have to merge it first.
    Then call remove() on the persistent instance returned by merge()

Transactions and Concurrency
1. Transaction definition:
    Application functionality requires that several things be done in one go.
    These steps collectively is called a transaction or unit of work

2. ACID, the criteria of transaction: atomicity, consistency, isolation, durability

3. Transactions are marked in the code between UserTransaction#begin() and UserTransaction#commit()

4. for transaction's exception handling, I can use UserTransaction#rollback() in the catch block

5. When you create an EntityManager, it looks for an ongoing JTA system transaction within the current thread of execution
   If the EntityManager finds an ongoing transaction, it joins the transaction by listening to transaction events.
   This means you should always call UserTransaction#begin() and EntityManagerFactory#createEntityManger() on the same thread
   if you want them to be joined.

6. If the EntityManger can't find a started transaction in the same thread when it's created,
   it is in a special unsynchronized mode.

7. Recommendation of when to throw transaction exceptions
  use fine-grained exception types to display better-looking (fatal) error messages, not for validation

8. How to handle exceptions
    Exceptions thrown by Hibernate are fatal.
    This means that you have to close the current persistence context.
    You aren't allowed to continue working with the EntityManager that threw an exception

    Render an error screen and/or log the error,
    and then let the user restart the conversation with the system using a fresh transaction and persistent context.

9. Transaction boundaries can either be coded or be marked by using annotations in J2EE environment

10. Transaction Isolation Issues (severity in decreased order)
  10.1 lost update:
        occurs if two transactions both update a data item
        and then the second transaction aborts,
        causing both changes to be lost.
        This occurs in systems that do not implement concurrency control,
        where concurrent transactions are not isolated.

  10.2 dirty read:
        occurs if a transaction reads
        changes made by another transaction that has not yet been committed.

  10.3 unrepeatable:
        occurs if a transaction read a data item twice
        and read different state each time.
        A special case of an unrepeatable read is the last commit wins problem.
        which is the last commit overwrite all the previous ones.

  10.4 phantom read:
        occur when a transaction executes a query twice,
        and the second result includes data that wasn't visible in the first result,
        or less data because something was deleted.

11. Four(4) ANSI isolation levels (in ascending order)
  11.1 Read uncommitted isolation,
          permits dirty read, but not lost update
  11.2 Read committed isolation (JPA default),
          permits unrepeatable read, but not dirty read
  11.3 Repeatable read isolation,
          read is repeatable, neither unrepeatable read nor dirty read are allowed
  11.4 Serializable isolation,
          emulates serial execution, that is as if transactions are executed one after another

12. guide lines of choosing the isolation level
  12.1 never choose "read uncommitted isolation"
  12.2 most applications do not need "serializable isolation"
       for phantom read are not usually problematic.

Fetch plans, strategies and profiles
1. Cartesian product problem
    This issue appears when you eagerly load two collections with one SQL query and JOIN operation.
    The result can contain many redundant items.
    Solution:
      Still use eager loading, but break a whole JOIN table prefetching into several single table prefetching

2. n+1 select problem:
    for items to be lazy loaded, additional SQL queries are needed.

3. Fetch plans (what data should be loaded):
  3.1 lazy persistent collections:
        @org.hibernate.annotations.LazyCollection(org.hibernate.annotations.LazyCollectionOption.EXTRA)
  3.2 lazy loading with interception
  3.3 eager loading of associations and collections

4. Fetch strategies (how the data should be loaded):
  4.1 prefetching data in batches
  4.2 prefetching collections with subselects
  4.3 eager fetching with multiple selects
  4.4 dynamic eager fetching

5. a fetch profile combines a fetch plan with a fetch strategy.
   encapsulated in reusable metadata or code

6. Optimization goal is to select the right fetching strategy for your fetch plan.
   so as to minimize the number of SQL statements and the complexity of each SQL statement
   especially want to avoid n+1 selects and Cartesian product issues

Cascading state transitions
1. Definition:
    When an entity instance changes state,
    associated entity instances may also be included in this state transition
    (cascading is not enabled by default)

2. An object persistence layer is said to implement persistence by reachability
   if any instance becomes persistent
   whenever the application creates a reference to the instance from another instance that is already persistent
   That is, ideally,
   an instance should become transient and be deleted form the database
   if it is not reachable via references from the root persistent object

3. Life cycle callback annotations (should be marked on methods, so as to represent callback)
  3.1 @PostLoad,
        triggered after an entity instance is loaded into the persistence context
        also called after refreshing an already-persistent instance.
  3.2 @PrePersist,
        called immediately when persist(), merge()
  3.3 @PostPersist,
        called after the database operation for marking an entity instance persistent is executed and identifier value is assigned.
      @PreUpdate, @PostUpdate
        executed before and after the persistence context is synchronized (flushing) with the database.
      @PreRemove, @PostRemove
        triggered before/after remove() is called

4. After defining the entity listener, it must be enabled (Annotated) on the target.
    @EntityListeners(XXXListener.class ... )
    public class TARGET{

    }

5. Hibernate will call entity life-cycle event listeners in the following order
  5.1 Default listeners for the persistent unit, in the order as declared in XML, metadata
  5.2 Listeners declared on an entity with @EntityListeners, in the given order.
  5.3 Callback methods declared in entity superclasses are first,
      starting with the most generic superclass.
      Callback methods on the entity class are last.

6. org.hibernate.Interceptor
    This is a Hibernate specific and more fine-grained entity life-cycle event listener

Writing queries


******************************************************************
the following are Java Brains Notes
******************************************************************

1. In order to let Hibernate persist an object, we should
  1.1 mark the class as @Entity
  1.2 Offer an id, usually a surrogate key
    Note: different type of keys
      1. candidate keys, a class can have multiple candidate keys, each of them can be used as a distinguisher of the class object
      2. primary key, one of the candidate keys chosen to be the to be used identifier of the class
                      primary key can be a single key, or a composite key, can be natural key or a surrogate key
                      2.1 natural key, one of the business properties in Java, chosen to be the primary key
                      2.2 surrogate key, a synthetic primary key, solely used in database to identify the object, has no business meaning in Java Class

2. Using the Hibernate API
  2.1 Create a session factory, by using Hibernate's configuration file
      Note: the sessionFactory object is often shared among classes and even among layers
  2.2 Create a session from the session factory
      Session session = sessionFactory.openSession()
  2.3 Use the session to save model objects
      session.save(OBJ_TO_BE_SAVED)
      session.getTransaction().commit()
  2.4 close the session
      session.close()
  Note: the database table is automatically created by Hibernate, there is no need to manually create the database table

3. Hibernate default recreate the database schema every time the application starts
   If we want to persist the data for longer time
   we can configure hibernate.cfg.xml's
  <property name="hbm2ddl.auto">update</property>

4. Class level annotations:
  4.1 @Entity, configure the whole entity class
  4.2 @Table, only used to configure the database table corresponding to the entity
  4.3 @Embeddable, mark the class as a value type, counter to entity type,
                   once its instance appears as a property of some other object,
                   the persistence strategy is always embed the current object
  4.4 @Inheritance, used to configure inheritance mapping
      @DiscriminatorColumn, on ParentClass, used to configure DiscriminatorColumn of inheritance
      @DiscriminatorValue, use to specify the DiscriminatorValue
  4.5 @Cacheable, let Hibernate know the annotated entity should be cached in the second level cache as well
      @Cache(usage=CacheConcurrencyStrategy.XXX), to additionally configure the second level cache
  4.6 @NamedQuery(name="NAME", query="HQL_QUERY"),
      @NamedNativeQuery(name="NAME", query="SQL_QUERY", resultClass=RESULT.class),
  4.7 @Version, marked on surrogate property version, use to enable versioning

5. property level annotations:
  5.1 @Id, used to mark identifiers, usually a surrogate with Long type
      @GeneratedValue, is used to mark @Id, specifying the strategy how Hibernate generate the surrogate key
  5.2 @Column, can be used to configure the database table column
  5.3 @Collection, marked on collection-typed properties. so that Hibernate will store the collection property accordingly
  5.4 @Basic
  5.5 @Transient, used to tell Hibernate whether to save the corresponding property or not
  5.6 @Temporal, used to configure Date and Time related properties, like Date
  5.6 @Lob, used to mark String/byte[] typed properties, to indicate their size can be larger than default String's Max size 255
        Hibernate will figure it out by itself, whether the Lob is blob or clob
  5.7 @Embedeed, to mark the current value property as a embedded type,
                 after this marking, the current property will be considered a sub-object  and dissected
                 each property of the Embedded object will appear with its master table
  5.8 @AttributeOverride, used to reconfigure the current property object
      e.g. @AttributeOverride(name="ORIGINAL_NAME"), column=@Column(name="NEW_NAME")
      @AttributeOverrides, if multiple @AttriubteOverride need to be specified,
                           @AttributeOverrides is used to group these @AttributeOverride annotations
  5.9 @EmbeddedId, used to mark value-typed Id
  5.10 @ElementCollection, is used to mark collection objects
                           the collection property is stored in a separate table,
                           default name is prefixed with containing class's classname
                           @ElementCollection has "fetch" property, which can be used to specify fetching strategies: EAGER/LAZY
       Note: collection object's declaration type should be the conforming interface,
             instead of the actual implementation class
             Also, the collection table stores the containing class's primary key as a foreign key to reference the parent
        @JoinTable, used to mark @ElementCollection, to perform join with other table, especially the parent
        @CollectionId, used to mark @ElementCollection,
                       It is a Hibernate specific annotation,
                       and is used to generate the primary key for the generated collection table.
  5.11 @OneToOne, used to mark entity associations
       @OneToMany
       @ManyToOne
       @ManyToMany
  5.12 @NotFound(action=NotFoundAction.IGNORE), used to mark the above association annotations
                                                specifying the IGNORE action, if the association is not yet established

6. get object (Actually is the Hibernate maintained object's corresponding proxy object)
  session.get(OBJECT.class, PRIMARY_KEY_VALUE)
  Note: the default "primary key" is the Id

7. when using sessionFactory to get objects,
   the returned object is not the desired class,
   but the default class's proxy (which inherits the desired class, of course)
   the default object fetching strategy is lazy-fetching, only the first level properties are fetch at the first time
   other deeper level properties are fetch when they are actually called/used.
   if session is closed before the deeper level objects are to be called,
   the fetch will fail.
   An alternative fetching-strategy is eager-fetching, which fetches all the properties at the first time

8. advanced association mapping: entity inside entity
   Note: the mapping is unidirectional PARENT_CLASS to CHILD|CHILDREN_PROPERTY
         if we would like to construct bidirectional association, we should annotate on both sides
         the association annotations can have "cascade" property,
         which let the user specify what to do with the subsequent entity when the current entity has been updated.
         so as to save the user's effort of manually update subsequent entity

  8.1 one-to-one mapping
    In the parent class, annotate the contained entity property with
    @OneToOne.

  8.2 one-to-many mapping
    In the parent class, annotate the contained entity collection property with
    @OneToMany
    After this Annotation, when doing persistence,
    an additional "association table" is created, containing the parent and children primary keys' combination

  8.3 many-to-one mapping
    Similar to one-to-many mapping,
    only the association's direction is inverse,
    this time the parent is the one with multiple instances.
    @ManyToOne

  8.4 bidirectional-one-to-many-and-many-to-one mapping in a joined table
    In one class, mark @OneToMany(mappedBy="OPPOSITE_TABLE_PROPERTY_NAME")
                  after this annotation,
                  we are expecting the other table will be specified as the joined table containing the association relationship
    In the other class, at the same time, mark @ManyToOne on the other entity property
                                               @JoinColumn("OPPOSITE_PROPERTY_NAME_IN_JOINED_TABLE")
    After this mapping, the bidirectional association is created in one joined table
                        so in total, instead of 3 tables, Hibernate will only generate 2 tables, one for each entity, association information only appears in one of them

  8.5 many-to-many mapping
      similar to one-to-many bidirectional mapping, we mark
      @ManyToMany on both classes' entity collection properties.
      In order to guide Hibernate to generate association on only one table,
      we need to add "mappedBy" argument on one of the @ManyToMany annotations,
      that is @ManyToMany(mappedBy="OPPOSITE_TABLE_PROPERTY_NAME")
      after this annotation, 3 tables in total will be created, 2 for entities, 1 for the joined association



9. Inheritance mapping strategies
    @Inheritance to configure inheritance behavior
      e.g. @Inheritance(strategy=InheritanceType.SINGLE_TABLE...)

    @DiscriminatorColumn
      e.g. @DiscriminatorColumn(
        name="NAME"
        discriminatorType=DiscriminatorType.XXX
      )

    @DiscriminatorValue, use to specify the DiscriminatorValue

  9.1 single table strategy:
        this is the default strategy of Hibernate,
        ("default", means only annotate the classes as @Entity, no additional annotation)
        map everything into the base class's table,
        additionally, add the string valued datatype (dtype) to each stored object instances
        this strategy will end up with many "holes" in the database table

  9.2 table per class strategy
      @Inheritance(strategy=Inheritance.TABLE_PER_CLASS), on the parent class
      no need to annotate the children classes other than @Entity
      behavior:
        children class will store all properties in itself's table
        (no matter whether they are declared directly in themselves or inherited)
      Downside of this strategy is there will be many data duplications in the database
      also, the child class table has no clue that who is its parent

  9.3 joined strategy
      @Inheritance(strategy=InheritanceType.JOINED), on the parent class
      behavior:
        all properties defined in a class will appear in its own class,
        except for duplications of "primary keys",
        duplicated primary keys will be used as foreign keys, when doing join table sql query on the child class,
        so as to get the whole information of the child class
      This is the best choice.

10. Hibernate Collections
  10.1 Bag semantic (allow duplication): List/ArrayList, etc.
  10.2 Bag semantic with ID (allow value duplication): List/ArrayList, etc.
  10.3 List semantic (allow duplication): List/ArrayList, etc.
  10.4 Set semantic (no duplication): set
  10.5 Map semantic: Map

11. Since there are many discrepancies between Java and relational data
    when storing objects into relational database,
    information like "association (due to the flat structure of relational table)" will be missed.
                     "inheritance"
    To compensate this, Hibernate will generate additional table to store the missing information

12. CRUD Operations
    session.save(OBJECT)
    session.get(OBJECT.CLASS, PRIMARY_KEY)
    session.update(OBJECT), (the "OBJECT" has to be "gotten" by the session previously)
    session.delete(OBJECT), delete() operation will transfer the object's state from "Persistent" to "Transient"

    Note: by default,
          we can still visit object's first level data outside the session,
          for the proxy object returned by the session contains first level data in them

13. Transient, Persistent and Detached Objects
  13.1 Transient object:
        Once the object has just been instantiated, but not yet saved by Hibernate

  13.2 Persistent object:
        Once the object is persisted by using Hibernate's session.save()
        Note:
              during the session,
              even if you do not specify the update operation,
              the changes of the persisted object will be updated automatically

  13.3 Detached object:
        After session.close(),
        objects "obtained from"/"saved into" session are detached.
        only cached data (like object's first level properties) can be accessed

14. @org.hibernate.annotation.Entity(selectBeforeUpdate=true),
    once we use this Hibernate specific annotation to mark the class
    when doing update,
    Hibernate will first do a select,
    only update if the instance of the class has been changed.
    This increases performance when change to the object is scarce, otherwise it will decrease performance.

15. Projection: certain column(s)/column(s') calculations of a table

16. Caches:
  16.1 First level cache: the session
  16.2 Second level cache:
        * across sessions in applications
        * across applications
        * across clusters
  In order to use the second level cache, two steps need to be followed
    Step1: configure Hibernate in hibernate.cfg.xml, to instruct Hibernate which cache provider it should use
    Step2: annotate the entity class need to be cached with @Cacheable (class level annotation)
           additionally, I can use @Cache(usage=CacheConcurrencyStrategy.XXX) to configure the caching strategy
  16.3 Third level cache -- query cache:
    Hibernate treats sql query result different from entity proxy objects returned by session.
    In order to use sql query cache, also two steps should be followed
    Step1: configure Hibernate in hibernate.cfg.xml, to instruct Hibernate which cache provider it should use
    Step2: after queries are created by sessions,
           we should also set the **query.cacheable(true)**, by doing so, two indications are made to Hibernate
           1. Hibernate should cache the query result in the query cache
           2. Before performing sql query request,
              Hibernate should firstly check to see whether the query cache contains the desired entity object.
              and sql queries are only preformed if the query cache does not contain it.
17. HQL Query
  17.1 Should be performed inside Hibernate's session,
       very similar to SQL

  17.2 HQL is "object-centric",
       so query should be based on object and properties,
       instead of on tables and columns

  17.3 SQL query injection: inject "value" into sql queries, then you may get undesired results

  17.4 ParameterBinding in query context: bind values to parameters in your SQL queries
       Hibernate uses ParameterBinding to prevent SQL injection.
       Syntax:
          you can use '?' or ':PARAM_NAME' as place holders in the query string,
          and use the query object's set(INDEX or PARAM_NAME, VALUE) to supply values to the indexedParameterPlaceHolders

  17.5 @NamedQuery, named HQL queries
                    allows programmer define queries at the @Entity Level,
                    which groups queries in one place and makes maintaining queries easier
        syntax:
          declaration:
            @NamedQuery(name="NAME", query="HQL_QUERY"),
            Note: the naming convention can be ENTITY_NAME.action, which describes the query
          use:
            session.getNamedQuery(NAME)

       Note: you can also use named SQL queries by declaring queries as
             @NamedNativeQuery(name="NAME", query="SQL_QUERY", resultClass=RESULT.class),
             as can be seen, if we use SQL query, we need to explicit indicate Hibernate which result class should it hand back
