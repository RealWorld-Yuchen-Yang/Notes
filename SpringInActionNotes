Part1 Core Spring
Chapter1 Spring Into Action
1. Wiring: The act of creating associations between application components is referred to as wiring

2. ApplicationContext loads bean definitions and wires them together

3. cross-cutting concerns: system services tend to cut across multiple components in a system
  concern examples are  logging, security issues, etc.

4. Boilerplate code: the code that you often have to write over and over again
                     to accomplish common and otherwise simple tasks.
                     i.e. JDBC, JMS, JNDI and consumption of REST services often involve a lot of commonly repeaeted code
                          which has nothing to do with business logic,
                          but just setting up the service

5. Two categorizes of Spring Containers: ApplicaitonContext and BeanFactory
   5.1 ApplicationContext is higher level and more preferable than BeanFactory
   5.2 Three most common flavours of ApplicationContexts
    5.2.1 ClassPathXmlApplicationContext, loads a context definition from an XML file located in the classpath
    5.2.2 FileSystemXmlApplicationContext, loads context definitions from an XML file in the file system
    5.2.3 XmlWebApplicationContext, loads context definitions from an XML file contained within a web application

6. A bean's life cycle inside Spring Container
  6.1 Spring instantiates the bean
  6.2 Spring injects values and bean references into the bean's properties.
  6.3 If the bean implements BeanNameAware, Spring passes the bean's ID to the setBeanName() method
  6.4 If the bean implements BeanFactoryAware, Springs calls the setBeanFactory() method, passing in the bean factory itself.
  6.5 If the bean implements ApplicationContextAware, Spring will call the setApplicationContext() method, passing in a reference to the enclosing application context.
  6.6 If any of the beans implements the BeanPostProcessor interface, Spring calls their postProcessBeforeInitialization() method.
  6.7 If any beans implement the InitializingBean interface, Spring calls their afterPropertiesSet() method.
      Similarly, if the bean was declared with an init-method, then the specified initialization will be called.
  6.8 If there are any beans that implement BeanPostProcessor, Spring will call their postProcessAfterInitialization() method
  ****************************************************************************************************************
  6.9 At this point, the bean is ready to be used by the application
      and will remain in the application context until the application is destroyed.
  ****************************************************************************************************************
  6.10 If any beans implement the DisposableBean interface, then Spring will call their destroy() methods.
       Likewise, if any bean was declared with a destroy method, then the specified method will be called.

7. We must wire our application objects into the Spring Container.

8. Spring Framework simplifies Java Development by
  8.1 dependency injection
  8.2 aspect-oriented programming
  8.3 boilerplate reduction

9. OSGi: Open Service Gateway initiative

10. Six Spring Modules
  10.1 Data access and integration(With integration points to persistent layer framework, like Hibernate, Mybatis)
    Transaction, JDBC, ORM, JMS(Java Message Service), OXM(Object-t-XML Mapping)
  10.2 Web and remoting(Spring MVC Framework is a counterpart of Apache Struts)
    Web, Servlet, Portlet, Struts
  10.3 AOP(Aspect Oriented Programming)
    AOP, Aspects
  10.4 Instrumentation
    Instrument, Instrument Tomcat
  10.5 Core Spring Container
    Beans, Core, Context, Expression, Context support
  10.6 Testing
    Test

11. LDAP: Light Weight Directory Access Protocol

12. Rather than acquiring dependencies on their own,
    dependent objects are given the objects that they depend on.
    Because dependent objects often only know about their injected objects through interfaces,
    coupling is kept low.

Chapter2. Wiring Beans
1. When declaring beans in XML, the root element of Spring configuration file is
   <beans> element from spring's bean schema
   i.e.
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
               http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
          <!-- Bean declarations go here -->
        </beans>

2. Injecting value through bean constructor

3. Inject object reference through bean constructor

4. Wire object produced by a static factory method.

5. Bean scoping
  5.1 By default, all Spring beans are singletons, that is a single instance per Spring container
    Note: Spring's notion of singleton is not true singleton(only a single instance of a class per classloader)
          nothing is stopping you from instantiating that same class in a more conventional way,
          or even defining several <bean> declarations that instantiate the same class

  5.2 To force Spring to produce a new bean instance each time one is needed,
      you should declare the bean's scope attribute to prototype.
  5.3 request, scopes a bean definition to an HTTP request. Only valid when used with a web-cable Spring context(i.e. Spring MVC)
  5.4 session, scopes a bean definition to HTTP session. Only valid when used with a web-capable Spring context(i.e. Spring MVC)
  5.5 global-session, scopes a bean definition to global HTTP session. Only valid when used in a portlet context

6. Injecting simple values by using <property name="PROPERTY_NAME" value="VALUE">
  ,similar to <constructor-arg value="VALUE">,
  except that instead of injecting values through a constructor argument,
  <property> injects by calling a property's setter method

7. Injecting referencing bean values by using <property name="PROPERTY_NAME" ref="VALUE">
  ,similar to <constructor-arg ref="MANAGED_BEAN_REFERENCE">,

8. Injecting inner beans.
  Inner beans are beans that are defined within the scope of another bean.
  An inner bean is defined by declaring a <bean> element directly as a child of the <property> element to which it'll be injected.
  or inside the <constructor-arg>
  Note: Inner beans are only useful for injection once and can't be referenced to by other beans

9. SpEL
  9.1 Literal Values
    Literal values can be wired into bean's property by using
    #{ }, a clue to Spring that the content that they contains a SpEL expression,
    it can be mixed with non-SpEL values
    i.e. <property name="count" value="#{5}"/>
    Note: Literal String values can be expressed in SpEL with either ' ' or " "

  9.2 Referencing beans, properties and methods
    SpEL can allow one bean to reference another bean by its **ID**
    i.e. <property name="instrument" value="#{saxophoneID}"
    after getting the reference of the bean, we can also use that reference to extract properties and invoke methods
    Note:
      The way to avoid the dreaded NullPointerException in SpEL is to use the null-safe accessor **'?.'**
      i.e. <property name="song" value="#{songSelector.selectSoong()?.toUpperCase()}"

  9.3 Working with types
    The key to working with class-scoped methods and constants in SpEL is to use the
    T() operator. It will return a Class-typed Object
    i.e. <property name="nultiplier" value="#T(java.lang.Math).PI"/>

  9.4 Performing operations on SpEL values
    9.4.1 Arithmetic: +, -, *. /, %, ^
    9.4.2 Relational: <, >, ==, <=, >=,
                      lt, gt, eq, le, ge
                      Note: the <, > symbols pose a problem when using these expressions in Spring's XML configuration,
                            so in the XML, it is better use the textural relational operators
    9.4.3 Logical: and, or, not, !
    9.4.4 Conditional: ?:(ternary), ?:(Elvis)
                      Note: a common use of the ternary operator is to check for a null value and to wire a default value in the event of a null
                            This can be done by using ?: for clarity
    9.4.5 Regular expression: matches
      i.e.
        <property name="validEmail" value="#{admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'}"/>

    9.4.6 Shifting through collections in SpEL
      9.4.6.1 Accessing collection members by using the [INDEX or 'KEY'] operator
      9.4.6.2 In addition to reading properties from a <util:propertise> declared collection,
              Spring makes two special selections of properties available to SpEL:
                * systemEnvironment, contains all of the environment variables on the machine running the application
                * systemProperties, contains all of the properties that were set in Java as the application started.
                                    (typically using the -D argument)
                                    i.e. -Dapplication.home=/etc/myapp
                                         then you could wire that value into the homePath
                                         <property name="homePath" value="#{systemProperties['application.home']}"/>
      9.4.6.3 **.?[CONDITION_EXPRESSION]** operator, Selecting collection members satisfies the CONDITION_EXPRESSION
        i.e. <property name="bigCities" value="#{cities.?[population gt 100000]}"/>

      9.4.6.4 **.^[CONDITION_EXPRESSION]**, select first element from the collection satisfying the CONDITION_EXPRESSION
              **.$[CONDITION_EXPRESSION]**, select last element from the collection satisfying the CONDITION_EXPRESSION

      9.4.6.5 **.![DESIRED_VALUE_EXPRESSION]**, projection operator, used to collect a particular property from each collection elements
        i.e. <property name="cityNames" value="#{cities.![name + ', ' + state]}"/>

    9.5 Using SpEL should be with caution,
        for SpEL expressions are ultimately just Strings that are tricky to test
        and have no IDE support for syntax checking

    9.6 SpEL can be used in both XML and Annotations

Chapter3 Minimizing XML configuration in Spring
1. Four kinds of autowiring, attempts to match all properties of the autowired bean with beants
            that
   When declaring a bean, it is like registering it in a database to be searched from.
   If a bean classA declared as "autowired" need Spring container to supply certain instances objects,
   based on different autowiring mechanism,
   the bean classA use that mechanism to search for the desired bean instance in the "Spring Container database"
   "auto" means that the underlying searching logic is handle and hidden by Spring framework

  1.1 byName, have the same **name** or **ID**
  1.2 byType, types are assignable to the properties
  1.3 constructor, types are assignable to the constructor
  1.4 autodetect, will try constructor wiring first,
                  if fails, byType will be tried.

2. Autowring byName:
  2.1 In Spring, everything is given a name.
  2.2 When declaring a bean A to be autowire="byName",
      we are telling spring to consider all properties of bean A
      and look for beans that are declared with the same names as the properties of bean A

3. Autowiring byType:
  If Spring finds more than one bean whose type is assignable to the autowired property,
  it is not going to guess which bean to autowire,
  and will instead throw an exception
  To overcome ambiguities with autowiring byType, Spring offers two options to declare beans
  * **primary="true|false"**, identify a primary autowire candidate for autowiring
  * **autowire-candidate="true|false"**, eliminate beans from autowiring candidacy

4. Autowiring by constructor:
  declare bean with property **autowire="constructor"**
  if the bean is configured using constructor injection, you may choose to put away the <constructor-arg> elements
  autowiring by "constructor" also tries to search the beans whose **type** satisfies the current declared bean's constructor
  further more, if a class has multiple constructors,
  any of which can be satisfied by autowiring, Spring won't attempt to guess which constructor to use

5. use **<beans default-autowire="byType|byName|constructor|autodetect"/>** to set default autowiring type
  5.1 default-autowire would be applied to all beans in a given Spring configuration file.
      however, we can have multiple configuration files that define a single application context
      each with their own default autowiring setting.
  5.2 we can also override the default autowiring strategy on a bean-by-bean basis

6. We can mix autowiring with explicit wiring <property ref="EXPLICIT_REFERENCE"/>
  6.1 we could use <null/> to force an autowired property to be null
  6.2 when using constructor autowiring,
      you must let Spring wire all of the constructor arguments,
      you can not mix <constructor-arg> elements with constructor autowiring

7. Wiring with annotations
  7.1 annotation allows for more fine-grained autowiring
      by allowing you select annotating certain properties for autowiring.
  7.2 to turn on annotation wiring,
      <beans>
        <context:annotation-config/>
      </beans>
  7.3 Spring supports 3 different annotations for autowiring
    7.3.1 Spring's own @Autowired annotation
      @Autowired can be used to annotate properties/methods, the logic behind it is autowire byType
      7.3.1.1 @Autowired(required=false), optional wiring
        Note: When multiple constructors are annotated with @Autowired, Spring will choose the constructor
              with the most arguments that can be satisfied.
      7.3.1.2 qualifying ambiguous dependencies
              To help @Autowired figure out which bean you want,
              you can accompany it with Spring's @Qualifier("BEAN_NAME|BEAN_ID|QUALIFIER_VALUE") annotation
              where, the QUALIFIER_VALUE is declared on the class need to be searched among
      7.3.1.3 Defining your custom qualifier annotation
        Declaration:
        @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface CUSTOMIZED_QUALIFIER_NAME
        {

        }
        Then we can use the **@CUSTOMIZED_QUALIFIER_NAME** annotation to annotate the beans, which are used to be annotated by @Qualifier
        @Autowired
        @@CUSTOMIZED_QUALIFIER_NAME
    7.3.2 JSR-330's @Inject annotation
      @Inject uses @Name("ID") to reduce ambiguity
    7.3.3 JSR-250's @Resource annotation
    7.3.4 @Value lets user wire primitive values such as int, boolean and String using annotation
          @Value can take SpEL as its value

8. <context:component-scan> does everything <context:annotation-config> does,
   plus it configures Spring to automatically discover beans and declare them for you.
   it works by scanning a package and all of its subpackages
   by default, the ID of the autodetected bean will be generated by camel-casing the class name
   we can also specify the ID by @Component("ID")

9.  <context:component-scan> looks for classes that are annotated with one of a handful of special stereotype annotations:
  @Component, a general-purpose stereotype annotation indicating that the class is a Spring component.
  @Controller, indicate that the class is a Spring MVC controller
  @Repository, indicates that the class defines a data repository
  @Service, Indicates that the class defines a service
  @Any custom annotation that is itself annotated with @Component

10. Component scanning can be customized using any of 5 kinds of filters.
  10.1 annotation, scan classes looking for those annotated with a given annotation at the type level.
                   The annotation to scan for is specified in the expression attribute.
  10.2 assignable, scan classes looking for those that are assignable to the type specified in the expression attribute
  10.3 aspectj, scan classes looking for those that match the AspectJ type expression specified in the expression attribute
  10.4 custom, use a custom implementation of org.springframework.core.type.TypeFilter as specified in the expression attribute
  10.5 regex, scan classes looking for those whose class names matches the regular expression specified in the expression attribute

11. @Configuration annotated class, Java-based configuration equivalent to <beans>

12. @Bean annotated method, Java-based configuration equivalent to <bean>
                            the return value of the annotated method will be the declared bean

Chapter4 Aspect-oriented Spring
1. Functions that span multiple points of an application are called cross-cutting concerns

2. DI(Dependency Injection) helps decouple application objects from each other.
   AOP(Aspect-Oriented Programming) helps decouple cross-cutting concerns from the objects that they affect.

3. Cross-cutting concerns can be modularized into special classes called aspects.

4. AOP terminology
  An aspect's functionality(advice) is woven into a program's execution at one or more join points
  pointcut defines which join points get advised.
  4.1 advice, the job of an aspect, defines both what and when of an aspect
    4.1.1 before, advice functionality takes place before the advised method is invoked
    4.1.2 after, advice functionality takes place after the advised method completes, regardless of the outcome
    4.1.3 after-returning, advice functionality takes place after the advised method successfully completes.
    4.1.4 after-throwing, advised functionality takes place after the advised method throws an exception
    4.1.5 around, wraps the advised method, provide some functionality before and after the advised method is invoked.
  4.2 pointcut
    Pointcuts help narrow down the join points adviced by the aspect
    it defines where
  4.3 join point
    A join point is a point in the execution of the application where an aspect can be plugged in.
    join point can be:
      * method being called
      * exception being thrown.
      * field being modified
    Note: Spring only supports method join points (no field/constructor join point)
  4.4 aspects
    an aspect is the merger of advice and pointcuts
    Spring aspects are implemented as proxies that wrap the target object
  4.5 introductions
    an introduction allows you to add new methods and attributes to existing classes
  4.6 weaving
    weaving is a process of applying aspects to a target object to create a new proxied object.
    aspects are woven into the target object at the specified join points.
    * compile time
    * classload time
    * runtime,

5. Spring's support for AOP comes in 4 flavors
  5.1 Classic Spring proxy-based AOP
  5.2 @AspectJ annotation-driven aspects
  5.3 Pure-POJO aspects
  5.4 Injected AspectJ aspects

6. selecting join points with pointcuts
  6.1 Spring leveraged AspectJ's pointcut expression language
    6.1.0 execution, matches join points that are method executions
      Note: the execution designator is the only one that actually performs matches.
            the other designators are used to limit those matches

    6.1.1 args(), limits join point matches to the execution of methods whose arguments are instances of the given types
    6.1.2 @args(), limits join point matches to the execution of methods whose arguments are annotated with the given annotation types
    6.1.3 this(), limits join point matches to those where the bean reference of the AOP proxy is of a given type
    6.1.4 target(), limits join point matches to those where the target object is of a given type
    6.1.5 @target(), limits matching to join points where the class of the executing object has an annotation of the given type
    6.1.6 within(), limits matching to join points within certain types
    6.1.7 @within(), limits matching to join points within types that have the given annotation
    6.1.8 @annotation(), limits join point matches to those where the subject of the join point has the given annotation
  6.2 Spring's bean() designator
    lets you identify beans by their ID within a pointcut expression

7. Writing pointcuts
  syntax:
    i.e. execution(* com.springinaction.springidol.Instrument.play(..)) && within(com.springinaction.springidol.*)
      Note:
        execution, trigger on method execution
        *, matches any return type
        com.springinaction.springidol.Instrument, the type that the method belongs to
        play(), the method
        .., taking any argument
        &&, combination operator
        within, when the method is called from within any class in the com.springinaction.springidol packages

8. Declaring aspects in XML, tag definitions
  8.1 <aop:advisor>, defines an AOP advisor
  8.2 <aop:after>, defines an AOP after advice, regardless of whether the advised method returns successfully.
  8.3 <aop:after-returning>, defines an AOP after-returning advice.
  8.4 <aop:after-throwing>, defines an AOP after-throwing advice.
  8.5 <aop:around>, defines an AOP around advice
  8.6 <aop:aspect>, defines an aspect
  8.7 <aop:aspectj-autoproxy>, enables annotation-driven aspects using @AspectJ
  8.8 <aop:before>, defines an AOP before advice
  8.9 <aop:config>, defines top-level AOP element. Most <aop:*> elements must be contained within <aop:config>
  8.10 <aop:declare-parents>, introduces additional interfaces to advised objects that are transparently implemented
  8.11 <aop:pointcut>, defines a pointcut
  Note: one <aop:aspect> can have multiple advices, like: <aop:before>, <aop:after>, <aop:after-returning>, <aop:after-throwing>, etc.
        and one advice can should have a "pointcut" and a "method" attribute

9. around advice, is passed in a ProceedingJoinPoint joinPoint parameter,
                  which is used to represent the execution method,
                  before invoking joinPoint.proceed(), is the same as before advice
                  after invoking joinPoint.proceed(), is the same as the after advices

10. advices can also be passed in customized parameters
  10.1 declare the argument name in the pointcut by using args() expression
  10.2 pass the declared parameter into the advice

11. Annotating aspects
  11.1 A class should be annotated with @Aspect so as to be considered as a Spring aspect
  11.2 we need to annotate a symbolic empty method as the pointcut by using @Pointcut
       The actual body of the annotated method is irrelevant.
       It is just a marker
       the name of the pointcut(which will be referenced later in advices) is derived from the name of the pointcut method.
  11.3 <aop:aspect>(XML tag declaration) has one distinct advantage over @AspectJ(the feature of annotating aspects by using AspectJ annotation)
       in that you do not need the source code of the class that's to provide the aspect's functionality.


Part2 Spring application essentials
Chapter5 Hitting the database
1. Service objects don't handle their own data access.
   Instead, they delegate data access to DAOs.
   DAO's interface keeps it loosely coupled to the service object

2. Spring's data access exceptions. They are all rooted from DataAccessException
   To take advantage of Spring's data access exceptions, we must use one of Spring's data access template
  2.1 CannotAcquireLockException
  2.2 CannotSerializeTransactionException
  2.3 CleanupFailureDataAccessException
  2.4 ConcurrencyFailureException
  2.5 DataAccessException
  2.6 DataAccessResourceFailureException
  2.7 DataIntegrityViolationException
  2.8 DataRetrievalFailureException
  2.9 DeadlockLoserDataAccessException
  2.10 EmptyResultDataAccessException
  2.11 IncorrectResultSizeDataAccessException
  2.12 IncorrectUpdateSemanticsDataAccessException
  2.13 InvalidDataAccessApiUsageException
  2.14 InvalidDataAccessResourceUsageException
  2.15 OptimisticLockingFailureException
  2.16 PermissionDeniedDataAccessException
  2.17 PermissionLockingFailureException
  2.18 TypeMismatchDataAccessException
  2.19 UncategorizedDataAccessException

3. A template method delegates the implementation-specific portions of the process to an interface.
   Different implementations of this interface define specific implementations of this portion of the process.

4. Spring separates the fixed and variable parts of the data access process into two distinct classes: templates and callbacks
         DAO template                        DAO callback
    4.1 prepare resources
    4.2 start transaction
                                         4.3 execute in transaction
                                         4.4 return data
    4.5 commit/rollback transaction
    4.6 close resources and handle errors

5. Using a data access template simply involves
   configuring the template as a bean in Spring context,
   and then wiring it into your application DAO
   The proxy chain:
    ApplicationDAO->DAOSupport->DataAccessTemplate->PersistenceFramework->Database

6. When possible, we should retrieve the pooled data source from an application server via JNDI

7. Spring's JDBC framework will shoulder the burden of resource management and exception handling
   Spring comes with three template classes to choose from
    7.1 JdbcTemplate
    7.2 NamedParameterJdbcTemplate
    7.3 SimpleJdbcTemplate, it is named as well, and we should always choose

8. Spring's data access exceptions are all runtime(unchecked) exceptions

9. Named parameters let user give each parameter in the SQL an explicit name
   and to refer to the parameter by that name when binding values to the statement
   i.e.
      9.1 in the query string
        private static final String SQL_INSERT_SPITTER =
        "insert into spitter (username, password, fullname) " +
        "values (:username, :password, :fullname)";
      9.2 in the template's update code
        public void addSpitter(Spitter spitter)
        {
          Map<String, Object> params = new HashMap<String, Object>();
          params.put("username", spitter.getUserName());//"username" refers to the declared named parameter in the SQL
          params.put("password", spitter.getPassword());
          params.put("fullname", spitter.getFullName());

          jdbcTemplate.update(SQL_INSERT_SPITTER, params);
          spitter.setId(queryForIdentity());
        }

      Note: the ":parameters" in the values refers to the parameters declared in insert clause

10. Spring has 3 DAOSupport classes for corresponding JdbcTemplates
  10.1 JdbcDaoSupport
  10.2 NamedParameterJdbcDaoSupport
  10.3 SimpleJdbcDaoSupport
  Note: the support class and its corresponding template class conform the Proxy pattern
        which is support class not only inherit the corresponding dao class,
        but also, it holds an instance of the dao class that it inherits from.
        The support class implements the dao's functionality by decorating it.

11.
