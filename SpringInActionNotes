Part1 Core Spring
Chapter1 Spring Into Action
1. Wiring: The act of creating associations between application components is referred to as wiring

2. ApplicationContext loads bean definitions and wires them together

3. cross-cutting concerns: system services tend to cut across multiple components in a system
  concern examples are  logging, security issues, etc.

4. Boilerplate code: the code that you often have to write over and over again
                     to accomplish common and otherwise simple tasks.
                     i.e. JDBC, JMS, JNDI and consumption of REST services often involve a lot of commonly repeaeted code
                          which has nothing to do with business logic,
                          but just setting up the service

5. Two categorizes of Spring Containers: ApplicaitonContext and BeanFactory
   5.1 ApplicationContext is higher level and more preferable than BeanFactory
   5.2 Three most common flavours of ApplicationContexts
    5.2.1 ClassPathXmlApplicationContext, loads a context definition from an XML file located in the classpath
    5.2.2 FileSystemXmlApplicationContext, loads context definitions from an XML file in the file system
    5.2.3 XmlWebApplicationContext, loads context definitions from an XML file contained within a web application

6. A bean's life cycle inside Spring Container
  6.1 Spring instantiates the bean
  6.2 Spring injects values and bean references into the bean's properties.
  6.3 If the bean implements BeanNameAware, Spring passes the bean's ID to the setBeanName() method
  6.4 If the bean implements BeanFactoryAware, Springs calls the setBeanFactory() method, passing in the bean factory itself.
  6.5 If the bean implements ApplicationContextAware, Spring will call the setApplicationContext() method, passing in a reference to the enclosing application context.
  6.6 If any of the beans implements the BeanPostProcessor interface, Spring calls their postProcessBeforeInitialization() method.
  6.7 If any beans implement the InitializingBean interface, Spring calls their afterPropertiesSet() method.
      Similarly, if the bean was declared with an init-method, then the specified initialization will be called.
  6.8 If there are any beans that implement BeanPostProcessor, Spring will call their postProcessAfterInitialization() method
  ****************************************************************************************************************
  6.9 At this point, the bean is ready to be used by the application
      and will remain in the application context until the application is destroyed.
  ****************************************************************************************************************
  6.10 If any beans implement the DisposableBean interface, then Spring will call their destroy() methods.
       Likewise, if any bean was declared with a destroy method, then the specified method will be called.

7. We must wire our application objects into the Spring Container.

8. Spring Framework simplifies Java Development by
  8.1 dependency injection
  8.2 aspect-oriented programming
  8.3 boilerplate reduction

9. OSGi: Open Service Gateway initiative

10. Six Spring Modules
  10.1 Data access and integration(With integration points to persistent layer framework, like Hibernate, Mybatis)
    Transaction, JDBC, ORM, JMS(Java Message Service), OXM(Object-t-XML Mapping)
  10.2 Web and remoting(Spring MVC Framework is a counterpart of Apache Struts)
    Web, Servlet, Portlet, Struts
  10.3 AOP(Aspect Oriented Programming)
    AOP, Aspects
  10.4 Instrumentation
    Instrument, Instrument Tomcat
  10.5 Core Spring Container
    Beans, Core, Context, Expression, Context support
  10.6 Testing
    Test

11. LDAP: Light Weight Directory Access Protocol

12. Rather than acquiring dependencies on their own,
    dependent objects are given the objects that they depend on.
    Because dependent objects often only know about their injected objects through interfaces,
    coupling is kept low.

Chapter2. Wiring Beans
1. When declaring beans in XML, the root element of Spring configuration file is
   <beans> element from spring's bean schema
   i.e.
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://www.springframework.org/schema/beans
               http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
          <!-- Bean declarations go here -->
        </beans>

2. Injecting value through bean constructor

3. Inject object reference through bean constructor

4. Wire object produced by a static factory method.

5. Bean scoping
  5.1 By default, all Spring beans are singletons, that is a single instance per Spring container
    Note: Spring's notion of singleton is not true singleton(only a single instance of a class per classloader)
          nothing is stopping you from instantiating that same class in a more conventional way,
          or even defining several <bean> declarations that instantiate the same class

  5.2 To force Spring to produce a new bean instance each time one is needed,
      you should declare the bean's scope attribute to prototype.
  5.3 request, scopes a bean definition to an HTTP request. Only valid when used with a web-cable Spring context(i.e. Spring MVC)
  5.4 session, scopes a bean definition to HTTP session. Only valid when used with a web-capable Spring context(i.e. Spring MVC)
  5.5 global-session, scopes a bean definition to global HTTP session. Only valid when used in a portlet context

6. Injecting simple values by using <property name="PROPERTY_NAME" value="VALUE">
  ,similar to <constructor-arg value="VALUE">,
  except that instead of injecting values through a constructor argument,
  <property> injects by calling a property's setter method

7. Injecting referencing bean values by using <property name="PROPERTY_NAME" ref="VALUE">
  ,similar to <constructor-arg ref="MANAGED_BEAN_REFERENCE">,

8. Injecting inner beans.
  Inner beans are beans that are defined within the scope of another bean.
  An inner bean is defined by declaring a <bean> element directly as a child of the <property> element to which it'll be injected.
  or inside the <constructor-arg>
  Note: Inner beans are only useful for injection once and can't be referenced to by other beans

9. SpEL
  9.1 Literal Values
    Literal values can be wired into bean's property by using
    #{ }, a clue to Spring that the content that they contains a SpEL expression,
    it can be mixed with non-SpEL values
    i.e. <property name="count" value="#{5}"/>
    Note: Literal String values can be expressed in SpEL with either ' ' or " "

  9.2 Referencing beans, properties and methods
    SpEL can allow one bean to reference another bean by its **ID**
    i.e. <property name="instrument" value="#{saxophoneID}"
    after getting the reference of the bean, we can also use that reference to extract properties and invoke methods
    Note:
      The way to avoid the dreaded NullPointerException in SpEL is to use the null-safe accessor **'?.'**
      i.e. <property name="song" value="#{songSelector.selectSoong()?.toUpperCase()}"

  9.3 Working with types
    The key to working with class-scoped methods and constants in SpEL is to use the
    T() operator. It will return a Class-typed Object
    i.e. <property name="nultiplier" value="#T(java.lang.Math).PI"/>

  9.4 Performing operations on SpEL values
    9.4.1 Arithmetic: +, -, *. /, %, ^
    9.4.2 Relational: <, >, ==, <=, >=,
                      lt, gt, eq, le, ge
                      Note: the <, > symbols pose a problem when using these expressions in Spring's XML configuration,
                            so in the XML, it is better use the textural relational operators
    9.4.3 Logical: and, or, not, !
    9.4.4 Conditional: ?:(ternary), ?:(Elvis)
                      Note: a common use of the ternary operator is to check for a null value and to wire a default value in the event of a null
                            This can be done by using ?: for clarity
    9.4.5 Regular expression: matches
      i.e.
        <property name="validEmail" value="#{admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com'}"/>

    9.4.6 Shifting through collections in SpEL
      9.4.6.1 Accessing collection members by using the [INDEX or 'KEY'] operator
      9.4.6.2 In addition to reading properties from a <util:propertise> declared collection,
              Spring makes two special selections of properties available to SpEL:
                * systemEnvironment, contains all of the environment variables on the machine running the application
                * systemProperties, contains all of the properties that were set in Java as the application started.
                                    (typically using the -D argument)
                                    i.e. -Dapplication.home=/etc/myapp
                                         then you could wire that value into the homePath
                                         <property name="homePath" value="#{systemProperties['application.home']}"/>
      9.4.6.3 **.?[CONDITION_EXPRESSION]** operator, Selecting collection members satisfies the CONDITION_EXPRESSION
        i.e. <property name="bigCities" value="#{cities.?[population gt 100000]}"/>

      9.4.6.4 **.^[CONDITION_EXPRESSION]**, select first element from the collection satisfying the CONDITION_EXPRESSION
              **.$[CONDITION_EXPRESSION]**, select last element from the collection satisfying the CONDITION_EXPRESSION

      9.4.6.5 **.![DESIRED_VALUE_EXPRESSION]**, projection operator, used to collect a particular property from each collection elements
        i.e. <property name="cityNames" value="#{cities.![name + ', ' + state]}"/>

    9.5 Using SpEL should be with caution,
        for SpEL expressions are ultimately just Strings that are tricky to test
        and have no IDE support for syntax checking

    9.6 SpEL can be used in both XML and Annotations

Chapter3 Minimizing XML configuration in Spring
1. Four kinds of autowiring, attempts to match all properties of the autowired bean with beants
            that
   When declaring a bean, it is like registering it in a database to be searched from.
   If a bean classA declared as "autowired" need Spring container to supply certain instances objects,
   based on different autowiring mechanism,
   the bean classA use that mechanism to search for the desired bean instance in the "Spring Container database"
   "auto" means that the underlying searching logic is handle and hidden by Spring framework

  1.1 byName, have the same **name** or **ID**
  1.2 byType, types are assignable to the properties
  1.3 constructor, types are assignable to the constructor
  1.4 autodetect, will try constructor wiring first,
                  if fails, byType will be tried.

2. Autowring byName:
  2.1 In Spring, everything is given a name.
  2.2 When declaring a bean A to be autowire="byName",
      we are telling spring to consider all properties of bean A
      and look for beans that are declared with the same names as the properties of bean A

3. Autowiring byType:
  If Spring finds more than one bean whose type is assignable to the autowired property,
  it is not going to guess which bean to autowire,
  and will instead throw an exception
  To overcome ambiguities with autowiring byType, Spring offers two options to declare beans
  * **primary="true|false"**, identify a primary autowire candidate for autowiring
  * **autowire-candidate="true|false"**, eliminate beans from autowiring candidacy

4. Autowiring by constructor:
  declare bean with property **autowire="constructor"**
  if the bean is configured using constructor injection, you may choose to put away the <constructor-arg> elements
  autowiring by "constructor" also tries to search the beans whose **type** satisfies the current declared bean's constructor
  further more, if a class has multiple constructors,
  any of which can be satisfied by autowiring, Spring won't attempt to guess which constructor to use

5. use **<beans default-autowire="byType|byName|constructor|autodetect"/>** to set default autowiring type
  5.1 default-autowire would be applied to all beans in a given Spring configuration file.
      however, we can have multiple configuration files that define a single application context
      each with their own default autowiring setting.
  5.2 we can also override the default autowiring strategy on a bean-by-bean basis

6. We can mix autowiring with explicit wiring <property ref="EXPLICIT_REFERENCE"/>
  6.1 we could use <null/> to force an autowired property to be null
  6.2 when using constructor autowiring,
      you must let Spring wire all of the constructor arguments,
      you can not mix <constructor-arg> elements with constructor autowiring

7. Wiring with annotations
  7.1 annotation allows for more fine-grained autowiring
      by allowing you select annotating certain properties for autowiring.
  7.2 to turn on annotation wiring,
      <beans>
        <context:annotation-config/>
      </beans>
  7.3 Spring supports 3 different annotations for autowiring
    7.3.1 Spring's own @Autowired annotation
      @Autowired can be used to annotate properties/methods, the logic behind it is autowire byType
      7.3.1.1 @Autowired(required=false), optional wiring
        Note: When multiple constructors are annotated with @Autowired, Spring will choose the constructor
              with the most arguments that can be satisfied.
      7.3.1.2 qualifying ambiguous dependencies
              To help @Autowired figure out which bean you want,
              you can accompany it with Spring's @Qualifier("BEAN_NAME|BEAN_ID|QUALIFIER_VALUE") annotation
              where, the QUALIFIER_VALUE is declared on the class need to be searched among
      7.3.1.3 Defining your custom qualifier annotation
        Declaration:
        @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
        @Retention(RetentionPolicy.RUNTIME)
        @Qualifier
        public @interface CUSTOMIZED_QUALIFIER_NAME
        {

        }
        Then we can use the **@CUSTOMIZED_QUALIFIER_NAME** annotation to annotate the beans, which are used to be annotated by @Qualifier
        @Autowired
        @@CUSTOMIZED_QUALIFIER_NAME
    7.3.2 JSR-330's @Inject annotation
      @Inject uses @Name("ID") to reduce ambiguity
    7.3.3 JSR-250's @Resource annotation
    7.3.4 @Value lets user wire primitive values such as int, boolean and String using annotation
          @Value can take SpEL as its value

8. <context:component-scan> does everything <context:annotation-config> does,
   plus it configures Spring to automatically discover beans and declare them for you.
   it works by scanning a package and all of its subpackages
   by default, the ID of the autodetected bean will be generated by camel-casing the class name
   we can also specify the ID by @Component("ID")

9.  <context:component-scan> looks for classes that are annotated with one of a handful of special stereotype annotations:
  @Component, a general-purpose stereotype annotation indicating that the class is a Spring component.
  @Controller, indicate that the class is a Spring MVC controller
  @Repository, indicates that the class defines a data repository
  @Service, Indicates that the class defines a service
  @Any custom annotation that is itself annotated with @Component

10. Component scanning can be customized using any of 5 kinds of filters.
  10.1 annotation, scan classes looking for those annotated with a given annotation at the type level.
                   The annotation to scan for is specified in the expression attribute.
  10.2 assignable, scan classes looking for those that are assignable to the type specified in the expression attribute
  10.3 aspectj, scan classes looking for those that match the AspectJ type expression specified in the expression attribute
  10.4 custom, use a custom implementation of org.springframework.core.type.TypeFilter as specified in the expression attribute
  10.5 regex, scan classes looking for those whose class names matches the regular expression specified in the expression attribute

11. @Configuration annotated class, Java-based configuration equivalent to <beans>

12. @Bean annotated method, Java-based configuration equivalent to <bean>
                            the return value of the annotated method will be the declared bean

Chapter4 Aspect-oriented Spring
1. Functions that span multiple points of an application are called cross-cutting concerns

2. DI(Dependency Injection) helps decouple application objects from each other.
   AOP(Aspect-Oriented Programming) helps decouple cross-cutting concerns from the objects that they affect.

3. Cross-cutting concerns can be modularized into special classes called aspects.

4. AOP terminology
  An aspect's functionality(advice) is woven into a program's execution at one or more join points
  pointcut defines which join points get advised.
  4.1 advice, the job of an aspect, defines both what and when of an aspect
    4.1.1 before, advice functionality takes place before the advised method is invoked
    4.1.2 after, advice functionality takes place after the advised method completes, regardless of the outcome
    4.1.3 after-returning, advice functionality takes place after the advised method successfully completes.
    4.1.4 after-throwing, advised functionality takes place after the advised method throws an exception
    4.1.5 around, wraps the advised method, provide some functionality before and after the advised method is invoked.
  4.2 pointcut
    Pointcuts help narrow down the join points adviced by the aspect
    it defines where
  4.3 join point
    A join point is a point in the execution of the application where an aspect can be plugged in.
    join point can be:
      * method being called
      * exception being thrown.
      * field being modified
    Note: Spring only supports method join points (no field/constructor join point)
  4.4 aspects
    an aspect is the merger of advice and pointcuts
    Spring aspects are implemented as proxies that wrap the target object
  4.5 introductions
    an introduction allows you to add new methods and attributes to existing classes
  4.6 weaving
    weaving is a process of applying aspects to a target object to create a new proxied object.
    aspects are woven into the target object at the specified join points.
    * compile time
    * classload time
    * runtime,

5. Spring's support for AOP comes in 4 flavors
  5.1 Classic Spring proxy-based AOP
  5.2 @AspectJ annotation-driven aspects
  5.3 Pure-POJO aspects
  5.4 Injected AspectJ aspects

6. selecting join points with pointcuts
  6.1 Spring leveraged AspectJ's pointcut expression language
    6.1.0 execution, matches join points that are method executions
      Note: the execution designator is the only one that actually performs matches.
            the other designators are used to limit those matches

    6.1.1 args(), limits join point matches to the execution of methods whose arguments are instances of the given types
    6.1.2 @args(), limits join point matches to the execution of methods whose arguments are annotated with the given annotation types
    6.1.3 this(), limits join point matches to those where the bean reference of the AOP proxy is of a given type
    6.1.4 target(), limits join point matches to those where the target object is of a given type
    6.1.5 @target(), limits matching to join points where the class of the executing object has an annotation of the given type
    6.1.6 within(), limits matching to join points within certain types
    6.1.7 @within(), limits matching to join points within types that have the given annotation
    6.1.8 @annotation(), limits join point matches to those where the subject of the join point has the given annotation
  6.2 Spring's bean() designator
    lets you identify beans by their ID within a pointcut expression

7. Writing pointcuts
  syntax:
    i.e. execution(* com.springinaction.springidol.Instrument.play(..)) && within(com.springinaction.springidol.*)
      Note:
        execution, trigger on method execution
        *, matches any return type
        com.springinaction.springidol.Instrument, the type that the method belongs to
        play(), the method
        .., taking any argument
        &&, combination operator
        within, when the method is called from within any class in the com.springinaction.springidol packages

8. Declaring aspects in XML, tag definitions
  8.1 <aop:advisor>, defines an AOP advisor
  8.2 <aop:after>, defines an AOP after advice, regardless of whether the advised method returns successfully.
  8.3 <aop:after-returning>, defines an AOP after-returning advice.
  8.4 <aop:after-throwing>, defines an AOP after-throwing advice.
  8.5 <aop:around>, defines an AOP around advice
  8.6 <aop:aspect>, defines an aspect
  8.7 <aop:aspectj-autoproxy>, enables annotation-driven aspects using @AspectJ
  8.8 <aop:before>, defines an AOP before advice
  8.9 <aop:config>, defines top-level AOP element. Most <aop:*> elements must be contained within <aop:config>
  8.10 <aop:declare-parents>, introduces additional interfaces to advised objects that are transparently implemented
  8.11 <aop:pointcut>, defines a pointcut
  Note: one <aop:aspect> can have multiple advices, like: <aop:before>, <aop:after>, <aop:after-returning>, <aop:after-throwing>, etc.
        and one advice can should have a "pointcut" and a "method" attribute

9. around advice, is passed in a ProceedingJoinPoint joinPoint parameter,
                  which is used to represent the execution method,
                  before invoking joinPoint.proceed(), is the same as before advice
                  after invoking joinPoint.proceed(), is the same as the after advices

10. advices can also be passed in customized parameters
  10.1 declare the argument name in the pointcut by using args() expression
  10.2 pass the declared parameter into the advice

11. Annotating aspects
  11.1 A class should be annotated with @Aspect so as to be considered as a Spring aspect
  11.2 we need to annotate a symbolic empty method as the pointcut by using @Pointcut
       The actual body of the annotated method is irrelevant.
       It is just a marker
       the name of the pointcut(which will be referenced later in advices) is derived from the name of the pointcut method.
  11.3 <aop:aspect>(XML tag declaration) has one distinct advantage over @AspectJ(the feature of annotating aspects by using AspectJ annotation)
       in that you do not need the source code of the class that's to provide the aspect's functionality.


Part2 Spring application essentials
Chapter5 Hitting the database
1. Service objects don't handle their own data access.
   Instead, they delegate data access to DAOs.
   DAO's interface keeps it loosely coupled to the service object

2. Spring's data access exceptions. They are all rooted from DataAccessException
   To take advantage of Spring's data access exceptions, we must use one of Spring's data access template
  2.1 CannotAcquireLockException
  2.2 CannotSerializeTransactionException
  2.3 CleanupFailureDataAccessException
  2.4 ConcurrencyFailureException
  2.5 DataAccessException
  2.6 DataAccessResourceFailureException
  2.7 DataIntegrityViolationException
  2.8 DataRetrievalFailureException
  2.9 DeadlockLoserDataAccessException
  2.10 EmptyResultDataAccessException
  2.11 IncorrectResultSizeDataAccessException
  2.12 IncorrectUpdateSemanticsDataAccessException
  2.13 InvalidDataAccessApiUsageException
  2.14 InvalidDataAccessResourceUsageException
  2.15 OptimisticLockingFailureException
  2.16 PermissionDeniedDataAccessException
  2.17 PermissionLockingFailureException
  2.18 TypeMismatchDataAccessException
  2.19 UncategorizedDataAccessException

3. A template method delegates the implementation-specific portions of the process to an interface.
   Different implementations of this interface define specific implementations of this portion of the process.

4. Spring separates the fixed and variable parts of the data access process into two distinct classes: templates and callbacks
         DAO template                        DAO callback
    4.1 prepare resources
    4.2 start transaction
                                         4.3 execute in transaction
                                         4.4 return data
    4.5 commit/rollback transaction
    4.6 close resources and handle errors

5. Using a data access template simply involves
   configuring the template as a bean in Spring context,
   and then wiring it into your application DAO
   The proxy chain:
    ApplicationDAO->DAOSupport->DataAccessTemplate->PersistenceFramework->Database

6. When possible, we should retrieve the pooled data source from an application server via JNDI

7. Spring's JDBC framework will shoulder the burden of resource management and exception handling
   Spring comes with three template classes to choose from
    7.1 JdbcTemplate
    7.2 NamedParameterJdbcTemplate
    7.3 SimpleJdbcTemplate, it is named as well, and we should always choose

8. Spring's data access exceptions are all runtime(unchecked) exceptions

9. Named parameters let user give each parameter in the SQL an explicit name
   and to refer to the parameter by that name when binding values to the statement
   i.e.
      9.1 in the query string
        private static final String SQL_INSERT_SPITTER =
        "insert into spitter (username, password, fullname) " +
        "values (:username, :password, :fullname)";
      9.2 in the template's update code
        public void addSpitter(Spitter spitter)
        {
          Map<String, Object> params = new HashMap<String, Object>();
          params.put("username", spitter.getUserName());//"username" refers to the declared named parameter in the SQL
          params.put("password", spitter.getPassword());
          params.put("fullname", spitter.getFullName());

          jdbcTemplate.update(SQL_INSERT_SPITTER, params);
          spitter.setId(queryForIdentity());
        }

      Note: the ":parameters" in the values refers to the parameters declared in insert clause

10. Spring has 3 DAOSupport classes for corresponding JdbcTemplates
  10.1 JdbcDaoSupport
  10.2 NamedParameterJdbcDaoSupport
  10.3 SimpleJdbcDaoSupport
  Note: the support class and its corresponding template class conform the Proxy pattern
        which is support class not only inherit the corresponding dao class,
        but also, it holds an instance of the dao class that it inherits from.
        The support class implements the dao's functionality by decorating it.

11. Declaring a Hibernate session factory
  the main interface for working with Hibernate is org.hibernate.Session.
  The session interface provides basic data access functionality such as the ability to save, update, delete and load objects

12. The standard way to get a reference to a Hibernate Session object is through an implementation of Hibernate's SessionFactory

13. Building Spring-free Hibernate
  With Hibernate manages Contextual session, there is no need of Spring's Template class
  You can wire a Hibernate session directly into DAO class

14. use @Autowired to annotate SessionFactory parameter, so as to get the SessionFactory injected by Spring

15. if <context:component-scan> is configured, Class annotated with @Repository will be treated as HibernateDao

16. <bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
    is a bean post processor,
    which adds an advisor to any bean that annotated with @Repository
    so that any platform-specific exception are caught and then rethrown as one of Springs unchecked data access exception.

17. Spring and the Java Persistence API
  17.1 Entity bean, a type of EJB that describes business objects that are persisted in a relational database
  17.2 The only real difference between application-managed and container-managed entity manager factories,
       as far as Spring is concerned,
       is how each is configured within the Spring application context.
    17.2.1
      Application-managed entity manager factories derive most of their configuration information from a configuration file
      persistence.xml.
      This file must appear in the META-INF directory with in the classpath
    17.3
      Container-managed JPA configure data source information in Spring's ApplicationContext

Chapter6 Managing Transactions
1. In software, all-or-nothing operations are called transactions.
   It is done by grouping a few steps into a single action.
   * if everything goes right, transaction committed
   * if something goes wrong, transaction rolled back

2. When writing to a database, we must ensure that the integrity of the data is maintained
   by performing the updates within a transaction.

3. Explaining transactions in only four words: ACID
  3.1 A, Atomic
         view all steps as a whole

  3.2 C, Consistent
         consistent with the business model

  3.3 I, Isolated
         Transactions should allow multiple users to work with the same data,
         without each user's work getting tangled up with the others.
         Translations should be isolated from each other,
         preventing concurrent reads and writes to the same data from occurring.
         Note: isolation typically involves locking rows and/or tables in a database

  3.4 D, Durable
         persistent

4. If your application uses only a single persistent resource,
   Spring can use the transactional support offered by the persistent mechanism

5. Transaction Managers delegate the responsibilities  for transaction management to a platform specific transaction.
  5.1 org.springframework.jdbc.datasource.DataSourceTransactionManager, working with Spring's JDBC abstraction support. Also useful when using iBATIS for persistence.
  5.2 org.springframework.orm.hibernate3.HibernateTransactionManager, using Hibernate3 for persistence.
  5.3 org.springframework.orm.jpa.JpaTransactionManager, Using Java Persistence API (JPA) for persistence
  5.4 org.springframework.transaction.jta.JtaTransactionManager, when you need distributed transactions or when no other transaction manager fits the need.

6. All of Spring's vendor-specific implementation of JpaDialect
   (EclipseLinkJpaDialect, HibernateJpaDialect, OpenJpaDialect, TopLinkJpaDialect)
   provide support for mixing JPA with JDBC.
   DefaultJpaDialect does not.

7. In Spring,
   You are limited to declaring transaction boundaries at the method level.
   If you need more fine-grained control over transactional boundaries,
   programmatic transactions are the only way to go.

8. TransactionsTemplates should be injected into the Application's Service class

9. Attributes that defines transactions.
  9.1 Propagation behavior, defines the boundaries of the transactions with respect to the client and to the method being called.
    Propagation rules, SpringInAction: P182:
      PROPAGATION_MANDATORY
      PROPAGATION_SUPPORTS
      PROPAGATION_NEVER
      PROPAGATION_NOT_SUPPORTED
      (the following will start a new transaction)
      PROPAGATION_REQUIRED
      PROPAGATION_ REQUIRES_NEW
      PROPAGATION_NESTED


  9.2 Isolation levels
    Concurrency can lead to the following problems
      * Dirty reads, occurs when one transaction reads data that has been written but not yet committed by another transaction.
                     If the changes are later rolled back, the data obtained by the first transaction will be invalid.
      * Nonrepeatable reads, occurs when a transaction performs the same query two or more times
                             and each time the data is different.
                             This is usually due to another concurrent transaction updating the data between the queries.
      * Phantom reads, similar to nonrepeatable reads,
                       occurs when a transaction reads several rows, and then a concurrent transaction inserts rows.
                       Upon subsequent queries, the first transaction finds additional rows that weren't there before.
    Isolation level
      ISOLATION_READ_UNCOMMITTED
      ISOLATION_READ_COMMITTED
      ISOLATION_REPEATABLE_READ
      ISOLATION_SERIALIZABLE

  9.3 Read-only
    read-only optimization are applied by the underlying data store when a transaction **begins**
    it only make sense to declare a transaction as read-only on methods with propagation behavior that may start a new transaction.
      * PROPAGATION_REQUIRED
      * PROPAGATION_REQUIRED_NEW
      * PROPAGATION_NESTED

  9.4 Transaction timeout
    timeout clock begins ticking when a transaction starts,
    it only make sense to declare a transaction timeout on methods with propagation behavior that may start a new transaction.
      * PROPAGATION_REQUIRED
      * PROPAGATION_REQUIRED_NEW
      * PROPAGATION_NESTED

  9.5 Rollback
    By default transactions are rolled back only on runtime exceptions(unchecked exceptions)

10. The <tx:annotation-driven> configuration element tells Spring to examine all beans in the application context
    and to look for beans that are annotated with @Transactional,
    either at the **class level** or at the **method level**

Building web applications with Spring MVC
1. Following a request through Spring MVC
  A request's job description is a courier, who carries information from one place to another

  Request -1)-> Dispatcher servlet -2)-> Handler mapping
                (Front Controller)
                |  |    ^   |
                |  |    |    --3)  -> Controller --4)--> delegate business to
                |  |    |                             Model and logical view name
                |  |    |                                              |
                |  |     ----------------5)----------------------------
                |  |
                |   ----------------------6)--------------------->ViewResolver
                --------------------------7)---------------------->View (JSP)

2. Setting up Spring MVC
  2.1 **DispatcherServlet** is the heart of Spring MVC.
    2.1.1 It is Spring MVC's front controller
    2.1.2 It should be configured in web.xml
    2.1.3 If not specified, the DispatcherServlet named DISPATCHER,
          will use /APP_NAME/WEB-INF/DISPATCHER-servlet.xml
          to load Spring's ApplicationContext
          and all spring web tier configuration
    2.1.4 the preferred DispatcherServlet mapping is as follows
      <servlet-mapping>
        <servlet-name>DISPATCHER</servlet-name>
        <url-pattern>/</url-pattern>
      </servlet-mapping>
    2.1.5 in the corresponding DISPATCHER-servlet.xml
      <beans xmlns="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:mvc="http://www.springframework.org/schema/mvc"
             xsi:schemaLocation="http://www.springframework.org/schema/mvc
                                 http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
                                 http://www.springframework.org/schema/beans
                                 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
             <mvc:resources mapping="/resources/**" location="/resources/" /><!-- Ant style wild card /** means any subfolder -->
      </beans>

3. Writing a basic controller (Request Handler)
  3.1 Developing resource-oriented controllers:
    Rather than write one controller for each use case,
    write a single controller for each kind of resource that the application serves
    Note: resources can be:
      3.1.1 Utils: like HomePageController, ForwardingController
      3.1.2 Domains: domain objects' controller

  3.2 Architecture of the web application:
    WebBrowser--------------------------->ServerSideWebTire
          ^                           (Contains controllers)
          |                                    |   |
          | ----------Static Resources<--------    |
          |              (ViewTire)            |   |
           ------JSP--- <--Template Engine<----     ---->ServiceTire----->Domain
                                                   |    ^             |
                                                   |    |             |
                                                   |     -------------
                                                   |
                                                    ------->PersistenceTire
                                                                (DAOs)
                                                                  |
                                                                   ----->Database

  3.3 Configuring Annotation Driven Controller(Handlers)
    Using one of the handler mappings is usually a matter of configuring it as a bean in Spring.
    DefaultAnnotationHandlerMapping maps request to controller methods that are annotated with @RequestMapping
    In the xml configuring ApplicaitonContext, mark it as <mvc:annotation-driven>

  3.4 **Model** object is the data passed between the controller and the view
      RequestHandling method can include almost anything as an argument.
      In the controller, it is just a blank parameter,
      we need to add useful attributes into it, and pass it done to the view

  3.5 The last thing a controller usually does is
      return a string as the name of the logical view,
      which will later on be used by ViewTire

  3.6 For Unit Testing the WebTire, the granularity is usually at the controller level
    3.6.1 MockService
    3.6.2 Create the controller
    3.6.3 Call handler method
    3.6.4 Assert results:
            1) View Logical name is resolved correctly
            2) Domain Model return data as expected

  3.7 Resolving views:
    3.7.1 a view resolver's job is to map a logical view name to some implementation of
           **org.springframework.web.servlet.View**
        i.e.
          <bean id="templateResolver"
                class="org.thymeleaf.templateresolver.ServletContextTemplateResolver">
            <property name="prefix" value="/WEB-INF/views/"/>
            <property name="suffix" value=".html"/>
            <property name="templateMode" value="HTML5"/>
          </bean>

    3.7.2 A lot of Spring MVC embraces a convention-over-configuration approach.

4. Splitting Spring Configuration across multiple XML files:
   One for service layer, One for persistence layer and another for data source configuration
   We do this by configuring the ContextLoaderListener in

      Deployment Descriptor **web.xml**

    i.e.
        <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/applicationContext*.xml</param-value>
        </context-param>

        <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
        </listener>

        As the naming of the configuration path /WEB-INF/applicationContext*.xml,
        Configuration files are called
          applicationContext-jpa.xml
          applicationContext-security.xml
          applicationContext.xml
          , etc.
        And the corresponding bean definitions for the other tires can be defined in their configuration xml respectively

5. Handling Controller Input
  5.1 Annotating the controller class
    At the class level, annotation @RequestMapping defines the root URL path that this controller will handle.
    At the methods level, annotation @RequestMapping defines the sub path, regarding to the class level root path

  5.2 URL query parameter can be passed in the controller as parameters.
      If the parameter name is the same as url parameter names, no annotation is needed
      If the parameter name is different from url parameter names, we should use @RequestParam("URL_PARAMETER_NAME") HANDLER_PARAMETER_NAME to annotate the parameter

  5.3 model object(org.springframework.ui.Model) used in the the controller handles its attributes as javaBean properties
      which means the conventional name of the properties conform the getter/setter of that property
      so we only need to add property value into the model, no attribute names need to be supplied

6. Processing forms (Spring in Action chapter 7.4)
  6.1 Working with forms in a web application involves two operations
    6.1.1 displaying the form (GET method handler)
    6.1.2 processing the form submission (POST method handler)
    we can use two handler methods to handle each of the operations

  6.2 @RequestMapping's params attribute can limit a handler method to only handling requests with certain parameters

  6.3 after letting the user inputs form information,
      we should sent the form back to the URL requesting the form creation.
      however, different from the first time of requesting the form to be edited is with HTTP GET method,
      after editing the form, we let the user use HTTP POST method to the same URL

  6.4 In the controller
    6.4.1 redirect, this concept means that we would like other handler to handle the request additionally.
              and "the other handler" is indicated by the new redirection URL name

    6.4.2 dispatch, this concept means to forward the request to a view for further display

  6.5 In Controllers, the request handler's parameter annotated with @Valid
      means that the parameter should pass validation before being passed into the handler body

  6.6 By redirecting form post request to another page,
      we can avoid duplicate submission of the form if the user clicks the "Refresh Button" in the browser

  6.7 In controller's request mapping annotation.
      "{VARIABLE_NAME}", this syntax is used to declare path variable
                         and this path variable is further passed into the handler as the @PathVariable VARIABLE_NAME in the signature of the handler
                         the actual value passed in is whatever value is in that location
                        i.e.
                          handler declaration:
                            @RequestMapping(value="/{username}", method=RequestMethod.GET)
                            public String showSpitterProfile(@PathVariable String username, Model model)
                            {
                              ...
                            }
                          when handling request with path "/username/habuma",
                          "habuma" is firstly assigned to the RequestMapping declared path variable "username"
                          and passed into the handler showSpitterProfile's parameter "username", which is annotated with @PathVariable and have the same name as the @RequestMapping declared variable
                          Note: in this case, the handler handles a request redirection,
                                the redirected URL is constructed by /spitter+spitter.getUserName()

  6.8 validating inputs:
    6.8.1 annotations can be placed on class(mostly domain entities) properties to specify validation rules.
    6.8.2 the message property set in the validation annotations are to be displayed
          in the form, when validation fails
          and the corresponding error message can be extracted in the JSP by BindingRequest's getFieldError() method
          or by using <sf:errors> in Spring's form binding JSP tag library
            6.8.2.1 path property, specifies the form field for which errors should be displayed

Working with Spring Web Flow
1. Spring Web Flow is an extension to Spring MVC that enables development of flow-based web application.
   It does this by separating the definition of an application's flow from the classes and views that implement the flow's behavior.
   All requests to a flow first go through Spring MVC's DispatcherServlet

2. The flow executor drives the execution of a flow.

3. The FlowHandlerMapping is wired with a reference to the flow registry so it knows when a request's URL maps to a flow.

4. Handler Adapter is the bridge between DispatcherServlet and Spring Web Flow.
   It handles flow requests and manipulates the flow based on those requests

5. Components of a flow:
  5.1 States, a state in a flow is where some logic is performed.
    5.1.1 "Action" state, are where the logic of a flow takes place
    5.1.2 "Decision" state, branch the flow into two directions,
                            routing the flow based on the outcome of evaluation flow data
    5.1.3 "End" state, the last stop for a flow.
                       once a  flow has reached its end state, the flow terminated
                       It is important to realize that a flow may have more than one end state.

    5.1.4 "Subflow" state, starts a new flow within the context of flow that is already underway.
                           just like submethods called by the main method in Java
    5.1.5 "View" state, pauses the flow and invites the user to participate in the flow.
                        by default, <view-state>'s id has 2 purposes.
                          1) Identifies the state within the flow
                          2) defines the logical name of the view.

  5.2 Transition
    transitions can be seen as roads that connect those points(States)
    A transaction is defined by the <transaction> element,
    a child of the various state elements
    More commonly transitions are defined to take place upon some event being fired.
      In a view state, the event is usually some action taken by the user.
      In an action state, the event is the result of evaluating an expression.
      In a subflow state, the event is determined by the ID of the subflow's end state.

    Global transition, common transitions in multiple states. i.e. "cancel" transition

  5.3 Flow data, informations to be carried
                 they are determined by the <var> tag
      Scoping of flow data:
        5.3.1 Conversation, created when a top-level flow starts and destroyed when the top-level flow ends
                            shared by a top-level flow and all of its subflows
        5.3.2 Flow, created when a flow starts and destroyed when the flow ends.
                    Only visible within the flow it was created by.

        5.3.2 Request, Created when a request is made into a flow and destroyed when the flow returns.
        5.3.4 Flash, created when a flow starts and destroyed when the flow ends.
                     It's also cleared out after a view state renders.
        5.3.5 View, created when a view state is entered and destroyed when the state exits.
                    Visible only within the view state.

        Note: when declaring a variable using the <var> element,
              the variable is always flow-scoped within the flow defining the variable
              When using <set>, <evaluate>, the scope is specified as a prefix for the name or result attribute.
              i.e. <set name="flowScope.theAnswer" value="42">

6. the _eventId_portion of an input button in a  viewState is a clue to Spring Web Flow,
   that what follows is an event that should be fired

7. after a subflow is finished, the url is directed back to the place originating the subflow, which just method calls.

8. Not all web applications are freely navigable.
   Sometimes, a user must be guided along
   asked appropriate questions, and led to specific pages based on their responses.

Securing Spring
1. For the most part, an application should play no part in securing itself.

2. It is better to keep security concerns separate from application concerns

3. Spring Security is a security framework implemented with Spring AOP and servlet filters.

4. Spring Security tackles security from two angles.
   4.1 To secure web requests and restrict access at the URL level

5. Java web application starts with an HttpServletRequest
   And if the request is the access point to a web application,
   then that's where security for a web application should begin

6. We will only need to configure one filter in the application's web.xml.
   It is not possible to inject beans into servlet filters registered in web.xml

7. It is important to know that the <intercept-url> rules are applied top to bottom.

8. Spring security's basic concepts are
  8.1 grant different kind of users different levels of authorities
  8.2 each part of the Spring Application should offer to the client only if they have matched level of authority

9. Securing View-level elements
  9.1 <security:accesscontrollist>, allows the body to be rendered if the currently authenticated user has one of the stipulated permissions in the specified domain object
  9.2 <security:authentication>, accesses properties of the current user's authentication object
  9.3 <security:authorize>, allows the body of the tag to be rendered if a specified security constraint has been met

10. you can access several of the user's authentication details using the <security:authentication> tag
  10.1 authorities, a collection of GrantedAuthority objects that represent the privileges granted to the user
  10.2 credentials, the credential that were used to verify the principal (commonly, this is the user's password)
  10.3 details, additional information about the authentication (IP address, certificate serial number, session ID, and so on.)
  10.4 principal, the user's principal

11. Spring Security's LDAP (LightWeight Directory Access Protocol)
    assumes that the LDAP server is listening on port 33389

12. Using Spring's remember-me functionality for user authentication
  The token that's stored in the cookie is made up of:
    username,
    password,
    expiration date,
    private key
  all encoded in an MD5 has before being written to the cookie
  Also the login request will need to include a _spring_security_remember_me parameter

13. Securing methods with @Secured,
    Only users with the authorities specified in @Secured's argument list can access the annotated method
    If the secured method is invoked in the course of a web request,
    the exception will be automatically handled by Spring Security's filter.
    Otherwise, you will need to write the code to handle the exceptions

14. Spring Security has a few implicit objects defined in SpEL

Working with remote services
1. Remoting is a conversation between a client application and a service

2. Conversation between two applications starts with a RPC (Remote Procedure Call)
   RPC is when execution flow is handed off from one application to another application.

3. Spring supports remoting for several different RPC models.
   including RMI(Remote Method Invocation), Caucho's Hessian and Burlap, Spring's own HTTP invoker, JAX-RPC and JAX-WS
   difference can be found in Spring in Action's p282

4. Spring manages the remote service by
   using a proxy factory bean that enables you to wire remote services
   into properties of your other beans as if they were local objects

5. If the call to the remote service results in a java.rmi.RemoteException,
   the proxy handles that exception and rethrows it as an unchecked RemoteAccessException

6. On the server side, you are able to expose the functionality of any Spring-managed bean as a remote using
   any of the RPC implementations.
   we can expose bean methods as remote services.

7. Working with remote services in Spring is purely a matter of configuration.
   No java code is needed.
   However, beans passed to or returned from remote calls may need to implement java.io.Serializable.

8. RmiServiceExporter works by wrapping the bean (POJO) in an adapter class,
   and binding the service adapter to the RMI registry

9. By default, RmiServiceExporter attempts to bind to an RMI registry on port 1099 of the local machine

10. working with Remote demands writing
  10.1 on the server side, export the bean method as an endpoint to be invoked by clients
  10.2 on the client side, we need to define proxy objects to access the server side end points
                          even though the client isn't aware that the given service is a remote service.
                          you may want to take designing the service's interface

11. RMI has difficulty working across firewalls,
    That is because RMI uses arbitrary ports for communication,
    which firewalls typically do not allow

12. HessianServiceExporter is a Spring MVC controller

13. HessianProxyFactoryBean and BurlapProxyFactoryBean produce proxy objects that talk to a remote service over HTTP
    (Hessian in binary, Burlap in XML)

14. Hessian and Burlap work well across firewalls,
    but use a proprietary object serialization mechanism

15. Spring HttpInvoker can be passed over firewalls
    and does not use proprietary serialization mechanism
    but it depends both client and server are Spring-based applications

16. A class(of course on the server side) that's annotated with @WebService is considered a web service endpoint
    and its methods, annotated with @WebMethod, are the operations

17. By extending SpringBeanAutoWiringSupport,
    you can annotate an endpoint's properties with @Autowired and its dependencies will be met

REST Support
1. REST: Representational State Transfer
  RPC is service-oriented and focused on actions and verbs,
  REST is resource-oriented and focused on the things and nouns that describe an application
  1.1 Representational, REST resource can be represented in virtually any form.
                        including XML, JSON (Javascript Object Notation), or even HTML
                        whatever form best suits the consumer of those resources
  1.2 State, state of a resource, when working with REST,
             we are more concerned with the state of the resource
             than with the actions we can take against resources
  1.3 Transfer, the transportation of data in some representational form,
                from one application to another

2. @PathVariable, enables controllers to handle requests for parameterized URLs
      i.e.
          @RequestMapping(value="/{id}", method=RequestMethod.GET)
          public String getSpittle(@PathVariable("id") long id, Model model)
          {
            ...
          }
          2.1 the first id, value="/{id}", is a declaration of the path variable id
          2.2 the second id, @PathVariable("id"), is extracting the value of the declared path variable id
          2.3 the third id, long id, is the parameter of the method getSpittle(long id, Model model),
                                     the path parameter's value is passed into the method parameter
          Note: if the declared path variable and the method parameter's name are the same,
                we do not need to path the variable name into @PathVariable annotation

3. @ResponseBody, view-based rendering can be bypassed altogether, using the @ResponseBody annotation and various HttpMethodConverter implementations

4. @RequestBody, along with HttpMethodConverter implementations, can convert inbound HTTP data into Java Objects passed into a controller's handler method

5. In the REST concept:
    URL represents a resource,
    And also URL uniquely identifies a resource (URI)
    It does not matter what is to be done to the resource
    The action is taken care of by the HTTP methods

6. Query parameters have no use in REST paradigm,
   for query parameters are used to guide server how to create resources,
   not used to identify a resource

7. Performing the REST verbs (CRUD, Create, Read, Update, Delete)
   HTTP methods is characterized by two traits: safety and idempotency.
   * safety, does not change the state of a resource
   * idempotency, repeated requests does not have further side effects after the first request
   NOTE: Safe methods are all idempotent

   7.1 GET, retrieves resource data from the server, safe, idempotent
   7.2 POST, post(update/create) data to the server, not safe, not idempotent
   7.3 PUT, put data to the server, not safe, idempotent
   7.4 DELETE, delete resource on the server, not safe, idempotent

8. methods annotated with @RequestMapping can also be annotated with @ResponseStatus
   @ResponseStatus(HttpStatus.NO_CONTENT), indicates to the client the HTTP status after the handler method

9. POST method is different from the rest methods (GET, PUT, DELETE)
   when use POST method to **create resources**,
   since the resource does not exist on the server yet,
   POST has to operate against a URL that isn't  the same as the resource it is creating.
   (GET, PUT, DELETE operates on the exact url of the manipulated resource)
   What is more, in the POST request handler,
   we should also set the Location header to the certain resource's URL

   we can annotate such post handler with @ResponseStatus.CREATED

10. Representing resources   
