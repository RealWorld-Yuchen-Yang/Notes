Introduction
1. Concerns of "utilization", "fairness", and "convenience" motivates the development of
    process and threads.
    Threads allow multiple streams of program control flow to coexist within a process

2. Processes and Threads:
  2.1 Processes,
      are synonym to Applications or programs
  2.2 Threads,
      are sometimes called lightweight processes,
      and most modern operating systems treat threads, not processes as the basic units of scheduling

3. Thread is the basic unit of scheduling

4. Safety, Liveness, Performance
  4.1 Safety, means nothing bad ever happens
  4.2 Liveness, means something good eventually happens
  4.3 Performance, means something good enough happens

Thread Safety
1. object's state:
    its data, stored in state variables such as instance or static fields.

2. Shared,
    a variable could be accessed by multiple threads.

3. mutable,
    the field's value could change during its lifetime

4. making an object thread-safe requires using synchronization to coordinate access to its mutable state

5. The primary mechanism for synchronization in Java is the **synchronized** keyword
   which provides exclusive lock
   but the term "synchronization" also includes the use of **volatile variables**, **explicit lock**, **atomic variables**

6. If multiple threads access the same mutable state variable without appropriate synchronization,
   your program is broken.
   There are three ways to fix it
  6.1 do not share the state variable across threads
  6.2 make the state variable immutable
  6.3 use synchronization whenever accessing the state variable

7. In any case, the concept of a thread-safe class makes sense only if the class encapsulates its own state.
   Thread safety may be a term that is applied to code,
   but it is about state, and it can only be applied to the entire body of code that encapsulates its state,
   which may be an object or an entire program

8. Definition of Thread-Safety
   A class is thread-safe if it behaves correctly when accessed from multiple threads,
   regardless of the scheduling or interleaving of the execution of those threads by the runtime environment,
   and with no additional synchronization or other coordination on the part of the calling code

9. Stateless objects are always thread-safe
   Stateless objects means:
   9.1 it has no fields and references no fields from other classes.
   9.2 the transient state for a particular computation exists solely in local variables that are stored on the thread's stack
       and are accessible only to the executing thread.

10. Atomicity
    atomic operations are either by nature (one command in JVM)
    or synthetic (in a synchronized block)

11. Race Condition:
    The possibility of incorrect results in the presence of unlucky timing
    A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime.
    The most common type of race condition is check-then-act, read-modify-write
    where a potentially state observation is used to make a decision on what to do next.

12. data race:
    arises when synchronization is not used to coordinate all access to a shared non-final field.
    different operations may overwrite the previous operation's result

13. for shared components,
    even the shared field is private to the object itself,
    it still risk the thread-safety problem,
    only "method level variables" can escape from such issue

14. Sequences of operations that must be executed atomically in order to remain thread-safe
    and atomic is defined as:
      Operation A and B are atomic with respect to each other if,
      from the perspective of a thread executing A,
      when another thread executes B,
      either all of B has executed or none of it has.
      An atomic operation is one that is atomic with respect to all operations,
      including itself,
      that operate on the same state

15. **java.util.concurrent.atomic** package contains atomic variable classes
    which are used for effecting atomic state transitions on numbers and object references.

16. Servlet is stateless by nature,
    if we introduce states (fields) into a servlet,
    only if the introduced field is thread safe,
    will let the Servlet containing it remain thread-safe

17. When multiple variables participate in an invariant,
    they are not independent (the value of one constrains the allowed value(s) of the others),
    Thus when updating one,
    you must update the others in the same atomic operations
    In this case,
    even though each call to set is atomic,
    there is still a window of vulnerability when one field has been modified and the other has not,
    and during that time other threads could see that the invariant does not hold.
    Solution: update related state variables in a single atomic operation by using "Locking"

18. Java Synchronized Block, contains two parts
  18.1 a reference to an object that will server as the lock
  18.2 a block of code to be guarded by that lock

19. a synchronized method
  a shorthand for a synchronized block,
  span an entire method body,
  whose lock is the object on which the method is being invoked.
  Note: static synchronized methods use the Class object for the lock

20. while synchronized methods can make individual operations atomic,
    additional locking is required - when multiple operations are combined into a compound action.

21. to improve efficiency while remain thread-safe,
    we should make the synchronized block as small as possible,
    at the same time,
    the atomicity should be guaranteed.

Sharing Objects
1. Synchronization also has another significant and subtle aspect: memory visibility
   We should ensure that when a thread modifies the state of an object,
   other threads can actually see the changes that were made

2. Out-of-thin-air safety:
    value a thread sees is a random value,
    not even at least the thread a inconsistent/stale value that is actually put by other thread

3. 64-bit numeric variables (double and long) are not declared volatile

4. Intrinsic locking can be used to guarantee the one thread sees the effects of another in a predicable manner

5. Volatile variables:
    a weaker form of synchronization,
    it ensures that updates to a variable are propagated predictably to other threads.
    When a field is declared **volatile**,
    the compiler and runtime are put on notice that this variable is shared and that operations on it should not be rendered with other memory operations
    Volatile variables are not cached in registers or in caches where they are hidden from other processors.
    so a read of a volatile variable always returns the most recent write by any thread

6. accessing a volatile variable performs no locking
   and so cannot cause the executing thread to block
   making volatile variables a lighter weight synchronization mechanism than **synchronized**

7. It is not recommended relying too heavily on volatile variables for visibility.
   code that relies on volatile variables for visibility of arbitrary state is more fragile and harder to understand than code that uses locking

8. The most common use for volatile variables is as a [completion| interruption| status] flag
   You can use volatile variables only when all the following criteria are met:
   8.1 writes to the variable do not depend on its current value,
       or you can ensure that only a single thread ever update the value
   8.2 The variable does not participate in invariants with other state variables
   8.3 Locking is not required for any other reason while the variable is being accessed

9. Publication and Escape
  publishing an object means making it available to code outside of its current scope
  An object that is published when it should not have been is said to have escaped

10. Internal state can be published to its inner class, which is a case of Escape (bad idiom)

11. Safe Construction practices:
      an object is in a predictable, consistent state only after its constructor returns.
      so publishing an object from within its constructor can publish an incompletely constructed object.

12. A common mistake that can let the **this** reference escape during construction is to start a thread from a constructor

13. There is nothing wrong with creating a thread in a constructor,
    but it is best not to start the thread immediately

14. Thread confinement:
      data is only accessed from a single thread, no synchronization is needed.

15. Stack confinement:
      a special case of thread confinement,
      in stack confinement, an object can only be reached through local variables

16. ThreadLocal
      a more formal means of maintaining thread confinement is ThreadLocal.
      which allows you to associate a per-thread value with a value-holding object
      ThreadLocal provides get and set accessors that maintain a separate copy of the value for each thread that uses it.

17. Immutability
      An object whose fields are **all final** may still be mutable,
      since final fields can hold references to mutable objects
      An object is immutable if:
      17.1 Its state cannot be modified after construction
      17.2 All its fields are final
      17.3 It is properly constructed (the **this** reference does not escape during construction)

18. It is the use of final fields that makes possible the guarantee of initialization safety
    that lets immutable objects be freely accessed and shared without synchronization

19. Just as it is a good practice (encapsulation) to make all fields **private**
    It is a good practice to make all fields final unless they need to be mutable

20. Safe publication idioms
      To publish an object safely,
      both the reference to the object and the object's state must be made visible to other threads at the same time.
      A properly constructed object can be safely published by one of the following methods:
      20.1 Initializing an object reference from a static initializer.
      20.2 Storing a reference to it into a **volatile** field or **AtomicReference**
      20.3 Storing a reference to it into a final field of a properly constructed object
      20.4 Storing a reference to it into a field that is properly guarded by a lock

21. Effectively immutable (a weaker form of immutable)
      Objects that are not technically immutable,
      but whole state will not be modified after publication,
      are called effectively immutable

22. If an object may be modified after construction,
    safe publication ensures only the visibility of the **as-published state**
    Synchronization must be used **not only to publish** a mutable object
    **but also every time the object is accessed**, to ensure visibility of subsequent modifications

23. A thread-safe object performs synchronization internally

Composing Objects
