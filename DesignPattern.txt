Creational Patterns****************************
1. Factory Method Pattern
  1.1 When to use a factory pattern?
    When we would like to use a method to produce several different class instances, and these classes share a common parent
  1.2 One advantage of using the factory pattern is that it can eliminate the (if-else/switch-case) statements.
    This is not totally remove the (if-else/switch-case),
    They are just moved into the factory.
    The advantage of doing so is that
      1.2.1 we hide the implementation from user
      1.2.2 we concentrate the object creation logic to one place, which increases maintainability

2. Abstract Factory Pattern
  2.1 What is the Abstract Factory Pattern?
      It is like a factory, but everything is encapsulated
      2.1.1 The method that orders the object
      2.1.2 The factory that build the object
      2.1.3 The final object
      2.1.4 The final objects contain objects that use the Strategy Pattern
        Composition: Object class fields are objects
  2.2 What can you do with an Abstract Factory?
    2.2.1 Allows you to create families of related objects without specifying a concrete class
    2.2.2 Use when you have many objects that can be added, or changed dynamically during runtime
    2.2.3 You can model anything you imagine and have those objects interact through common interfaces
  2.3 The Abstract Factory Object passes the concrete Factory Object to the Product's constructor
      so as to let the concrete Factory produce components used to build the Product in the Product itself's constructor

3. Builder Pattern
  3.1 What is the Builder Pattern?
    Builder Pattern is used to create objects made from a bunch of other objects
    3.1.1 When you want to build an object made up from other objects
    3.1.2 When you want the creation of components to be independent of the main object
    3.1.3 Hide the creation of the parts from the client so both are not dependent
    3.1.4 The builder knows the specifics and nobody else does

4. Singleton Pattern
  4.1 It is used when you want to eliminate the option of instantiating more than one object
  4.2 To prevent threads mess up singleton,
      inside the singleton getInstance(), we can
        synchronized(Singleton.class)
        {
          if(firstInstance == null)
          {
            firstInstance = new Singleton();
          }
        }
      we do not mark the getInstance() synchronized is because it can dramatically slow down our program.

5. Prototype Pattern
  5.1 Prototype pattern creates new objects (instances) by cloning (copying) other objects
  5.2 It allows adding of any subclass instance of a known super class at run time
      Note: the super class should extend Clonable
  5.3 When there are numerous potential classes that you want to only use if needed at runtime
  5.4 It reduces the need for creating subclasses.

Structural Patterns****************************
1. Adapter Pattern

2. Bridge Pattern

3. Composite Pattern

4. Decorator Pattern
  4.1 composition is dynamic,
      inheritance is static
  4.2 decorator pattern uses composition and allows you modify an object dynamically
  4.3 you would use it when you want the capability of inheritance with subclass.
      but you need to add functionality at run time
  4.4 It simplifies code, because you add functionality using many simple classes
  4.5 Rather than rewrite old code, you can extend with new code
  4.6 the decorator inherits from the entity that its going to decorate,
      and it also stores an instance of that entity,
    4.6.1 the reason for the decorator to hold an instance of the entity to be decorated is because
          that instance is the source we would like to decorate
    4.6.2 the reason for the decorator to inherit the decorated entity is because
          we would like to get the same type of instance after it is decorated

5. Facade Pattern

6. Flyweight Pattern

7. Proxy Pattern

Behavioral Patterns****************************
1. Chain of Responsibility Pattern

2. Command Pattern

3. Interpreter Pattern

4. Iterator Pattern

5. Mediator Pattern

6. Memento Pattern

7. Observer Pattern
  7.1 When do you need observer pattern?
    When you need many other objects to receive an update when another object changes
  7.2 The subject(publisher) does not need to know any information of the Observers
  7.3 Negatives: The subject may send updates that don't matter to the Observer(subscriber)
  7.4 We can register the Observer into the Subject, whose reference are stored as a list in the subject
      The subject notifies the registered observers automatically of any state changes, usually by calling one of their methods.
  7.5 The observer can also store a reference to its subject, so that it can call methods of the object that it is observing

8. State Pattern

9. Strategy Pattern
  9.1. Avoid Interfaces that Just Force Action
  9.2. The way of implementing strategy pattern is by defining Interface type field in a superclass
    so that in the subclasses, they can insert behavioral implementation of that Interface type field
  9.3 Another explanation of strategy pattern:
    Define a family of algorithms(behaviors), encapsulate each one, and make them interchangeable.
    The strategy pattern lets the algorithm vary independently from client that use it.
  9.4. This decoupling technique is called composition instead of hard-coded inheritance
  9.5 When to use Strategy Pattern:
    9.5.1: When you want to define a class that will have one behavior that is similar to other behaviors in a list
    9.5.2: When you need to use one of several behaviors dynamically
  9.6 Benefits
    9.6.1 Often reduces long list of conditionals
    9.6.2 Avoid duplicate code
    9.6.3 Keeps class changes from forcing other class changes
    9.6.4 Can hide complicated/secret code from the user
  9.7 Negatives:
    9.7.1 Increased Number of Objects/Classes

10. Template Method Pattern

11. Visitor Pattern
