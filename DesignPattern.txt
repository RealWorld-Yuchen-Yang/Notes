1. Strategy Pattern
  1.1. Avoid Interfaces that Just Force Action
  1.2. The way of implementing strategy pattern is by defining Interface type field in a superclass
    so that in the subclasses, they can insert behavioral implementation of that Interface type field
  1.3 Another explanation of strategy pattern:
    Define a family of algorithms(behaviors), encapsulate each one, and make them interchangeable.
    The strategy pattern lets the algorithm vary independently from client that use it.
  1.4. This decoupling technique is called composition instead of hard-coded inheritance
  1.5 When to use Strategy Pattern:
    1.5.1: When you want to define a class that will have one behavior that is similar to other behaviors in a list
    1.5.2: When you need to use one of several behaviors dynamically
  1.6 Benefits
    1.6.1 Often reduces long list of conditionals
    1.6.2 Avoid duplicate code
    1.6.3 Keeps class changes from forcing other class changes
    1.6.4 Can hide complicated/secret code from the user
  1.7 Negatives:
    1.7.1 Increased Number of Objects/Classes

2. Observer Pattern
  2.1 When do you need observer pattern?
    When you need many other objects to receive an update when another object changes
  2.2 The subject(publisher) does not need to know any information of the Observers
  2.3 Negatives: The subject may send updates that don't matter to the Observer(subscriber)
  2.4 We can register the Observer into the Subject, whose reference are stored as a list in the subject
      The subject notifies the registered observers automatically of any state changes, usually by calling one of their methods.
  2.5 The observer can also store a reference to its subject, so that it can call methods of the object that it is observing

3. Factory Pattern
  3.1 When to use a factory pattern?
    When we would like to use a method to produce several different class instances, and these classes share a common parent
  3.2 One advantage of using the factory pattern is that it can eliminate the (if-else/switch-case) statements.
    This is not totally remove the (if-else/switch-case),
    They are just moved into the factory.
    The advantage of doing so is that
      3.2.1 we hide the implementation from user
      3.2.2 we concentrate the object creation logic to one place, which increases maintainability

4. Abstract Factory Pattern
  4.1 What is the Abstract Factory Pattern?
      It is like a factory, but everything is encapsulated
      4.1.1 The method that orders the object
      4.1.2 The factory that build the object
      4.1.3 The final object
      4.1.4 The final objects contain objects that use the Strategy Pattern
        Composition: Object class fields are objects
  4.2 What can you do with an Abstract Factory?
    4.2.1 Allows you to create families of related objects without specifying a concrete class
    4.2.2 Use when you have many objects that can be added, or changed dynamically during runtime
    4.2.3 You can model anything you imagine and have those objects interact through common interfaces
  4.3 The Abstract Factory Object passes the concrete Factory Object to the Product's constructor
      so as to let the concrete Factory produce components used to build the Product in the Product itself's constructor

5. Singleton Pattern
  5.1 It is used when you want to eliminate the option of instantiating more than one object
  5.2 To prevent threads mess up singleton,
      inside the singleton getInstance(), we can
        synchronized(Singleton.class)
        {
          if(firstInstance == null)
          {
            firstInstance = new Singleton();
          }
        }
      we do not mark the getInstance() synchronized is because it can dramatically slow down our program.

6. Builder Pattern
  6.1 What is the Builder Pattern?
    Builder Pattern is used to create objects made from a bunch of other objects
    6.1.1 When you want to build an object made up from other objects
    6.1.2 When you want the creation of components to be independent of the main object
    6.1.3 Hide the creation of the parts from the client so both are not dependent
    6.1.4 The builder knows the specifics and nobody else does
