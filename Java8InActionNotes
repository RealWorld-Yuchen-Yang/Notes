Why should you care
1. free parallelism by using the Stream library

2. behavior parameterization
    pass methods (your code) as arguments to other methods

3. functional programming V.S. imperative programming
  3.1 functional programming:
        does not share mutable data,
        able to pass methods and functions to other methods
        it behaves as a mathematical function and has no (visible) side effects
  3.2 imperative programming,
        describe a program in terms of a sequence of statements that mutate state.

4. Java 8 method reference :: syntax (meaning "use this method as a value")
   Note: this is "named functions, a counterpart of lambdas"
    e.g. File::isHidden,
          is a reference to File class's isHidden() method
          which can be used (invoked) later on

5. Lambdas: anonymous functions
    As well as allowing (named) methods to be first-class values,
    Java 8 allows a richer idea of functions as values, including lambdas (or anonymous functions)

    compared with named methods:
      new lambda syntax is more concise for cases where you do not have a convenient method and class available
      they are used when such method is seldom used

6. Predicate:
  6.1 mathematics concept:
        something functions like,
        take a value for an argument and **returns true or false**

7. Core: a synonym of CPU
   computing cluster: computers connected together with fast networks

8. Comparing Collections API and Streams API:
  8.1 similarity:
        both provide access to sequences of data items
  8.2 differences:
    8.2.1 Collections: mostly about storing and accessing data.
    8.2.2 Streams: mostly about describing computations on data.
            Note: the key point here is that Streams allows and encourages the elements within a Stream to be processed in parallel
                  Often the fastest way to filter a Collection is to convert it to a Stream,
                  process it in parallel,
                  convert it back to a list

9. Default methods on interfaces:
    an interface can now contain method signatures for which an implementing class doesn't provide an implementation,
    The missing method bodies are given as part of the interface (default implementations)
    rather than in the implementing class
    Note: default methods are declared by using the "default" key word

10. Other interesting ideas from functional programming include
  10.1 dealing with null (by using Optional<T>)
  10.2 pattern matching (can be think of as "enhanced switch-case")

Passing code with behavior parameterization
1. Behavior parameterization:
    the ability to tell a method to take multiple behaviors (or strategies) as parameters
    and use them internally to accomplish different behaviors
    (this is related to strategy design pattern, which lets you define a family of algorithms,
    encapsulate each algorithm (strategy),
    and select an algorithm at run-time)

2. for passing behavior code snippets,
   by using lambda expression,
   it saves you the effort of creating multiple "ConcreteBehavior" classes,
   which eliminates verbosity

3. Runnable interface
    In Java, you can use the Runnable interface to represent a block of code to be executed.
    Thread class takes a Runnable parameter, which represents the code snippet the thread will run

    //java.lang.Runnable
    public interface Runnable{
      public void run();
    }

Lambda Expressions
1. For the passed in behavior (code snippet)
   you can decide to run it when a certain event happens or at certain points in an algorithm

2. Lambda expression:
    can be understood as a concise representation of an anonymous function that can be passed around:
      it doesn't have a name,
      but it has a list of parameters, a body, a return type, and also possibility a list of exceptions that can be thrown
  2.1 Function:
        a lambda isn't associated with a particular class like a method is.
  2.2 passed around:
        a lambda expression can be passed as argument to a method or stored in a variable
  2.3 syntax;
        (lambda parameters) -> {lambda body}
        Note:
          2.3.1 lambda parameters:
            2.3.1.1 the type of parameters are optional, since they can be indicated from the target (functional interface)
            2.3.1.2 if there is only one parameter, the parenthesis surrounding the parameter list can also be omitted
          2.3.2 lambda body
            2.3.2.1 if the lambda body is composed of only one statement:
                    no "return" need to specified,
                    the return type is compatible with either "void" or the "statement's result"
            2.3.2.2 if the lambda body is composed of more than one statements:
                    if the return type is not "void",
                    an explicit "return" statement should be supplied

  2.4 Special cases:
    () -> {}, represents a method taking no parameter, and has an empty body

3. Where exactly can you use lambdas?
    You can use a lambda expression in the context of a functional interface

4. Functional interface:
    Interfaces has exactly one abstract method.
    Note: functional interface can still have many default methods

5. lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline
   and treat the whole expression as an instance of a functional interface (a concrete implementation of the functional interface)

6. When passing a lambda expression as an argument into a method,
   it is registered into that method.
   such method is defined in advance,
   which takes a functional interface as a parameter,
   and in its body,
   it calls the only abstract method on that functional interface at some operational point

7. Function descriptor
    The signature of the abstract method of the functional interface essentially describes the signature of the lambda expression

8. Common functional interfaces in Java 8
      Functional Interface    Function descriptor  Function descriptor signature   Primitive specializations
  8.1 Predicate<T>              T -> boolean       boolean test(T t)               IntPredicate, LongPredicate, DoublePredicate
  8.2 Consumer<T>               T -> void          void accept(T t)                IntConsumer, LongConsumer, DoubleConsumer
  8.3 Function<T>               T -> R             R apply(T t)                    IntFunction<R>, IntToDoubleFunction, IntToLongFunction,
                                                                                   LongFunction<R>, LongToDoubleFunction,
                                                                                   LongToIntFunction, DoubleFunction<R>, ToIntFunction<T>,
                                                                                   ToDoubleFunction<T>, ToLongFunction<T>
  8.4 Supplier<T>               () -> T                                            BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier
  8.5 BinaryOperator<T>         (T, T) -> T                                        IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator
  8.6 BiPredicate<L, R>         (L, R) -> boolean
  8.7 BiConsumer<T, U>          (T, U) -> void                                     ObjIntConsumer<T>, ObjLongConsumer<T>, ObjDoubleConsumer<T>
  8.8 BiFunction<T, U, R>       (T, U) -> R                                        ToIntBiFunction<T, U>, ToLongBiFunction<T, U>, ToDoubleBiFunction<T, U>

9. @FunctionalInterface annotation
    This annotation is used to indicate that the interface is intended to be a functional interface.
    The compiler will return a meaningful error if you define an interface using the @FunctionalInterface annotation
    and it isn't a functional interface
    Note: this annotation is not mandatory,
          but it is a good practice to use it when an interface is designed for that purpose

10. Function descriptor syntax:
      (T, U) -> R
    represents:
      a function with two arguments of respectively generic type T and U
      and that has a return type of R

11. Note that none of the functional interfaces allow for a checked exception to be thrown.
    however unchecked exception (RuntimeException) can be thrown

12. Functional interface is not does not inherit Object class, for Object does not have exactly one abstract method

13. Using local variables
  13.1 free variables:
        variables that aren't the parameters and defined in an outer scope
  13.2 capturing lambda:
        lambda expressions who use free variables inside their expression body
  13.3 lambda expressions can use free variables,
       but those free variables should be explicitly declared "final" or are effectively final
       (In other words, lambda expressions can capture local variables that are assigned to them only once)
  13.4 Comparing "closure" with "lambda expression"
        a closure is an instance of a function that can reference nonlocal variables of that function with no restrictions
           that is the closure can access and modify variables defined outside its scope
14. Method references let you reuse existing method definitions and pass them just like lambdas
  14.1 remember that "no brackets" are needed in method references,
       because you are not actually calling the method
  14.2 Recipe for constructing method references
    14.2.1 A method reference to a static method
    14.2.2 A method reference to an instance method of an arbitrary type
           Note: here the "arbitrary type" is in the parameter list
    14.2.3 A method reference to an instance method of an existing object
           Note: here, the "existing object" is not in the parameter list, but in the expression body

15. constructor reference
  15.1 syntax: ClassName::new
  15.2 Note that no matter how many arguments the constructor takes,
       the reference to a constructor is always represented as ClassName::new
       however, when using a particular constructor reference,
       we can pass the explicit parameter list

16. Composing Predicates
      The predicate interface includes three methods that let you reuse an existing Predicate to create more complicated ones:
      16.1 negate()
      16.2 and()
      16.3 or()

17. Composing Functions
  17.1 f.andThen(g)
        means f is computed first,
        then the result is passed into g for further computation
  17.2 f.compose(g)
        means f(g()) in mathematical expression,
        who compute g() first,
        then input the result into f() for further computation

  Note: f and g are of "Function" functional interface

18 The "Execute Around Pattern"
  18.1 description:
         you need to execute a bit of behavior in the middle of code that is always required in a method.
         e.g. resource allocation and cleanup
  18.2 for such pattern,
       we can use lambda expression to gain additional flexibility

Functional Style Data Processing
Working with Streams
1. Streams:
 1.1 Definition:
       A sequence of elements from a source that supports data processing
   Java API that lets you manipulate collections of data in a declarative way
   (you express a query rather than code an ad hoc implementation for it)
   Streams can be processed in parallel transparently
 1.2 Note that generating a stream from an ordered collection preserves the ordering.
 1.3 Data processing operations:
       Streams support database-like operations and common operations from functional programming language to manipulate data,
       such as: filter, map, reduce, find, match, sort, etc.
       Stream operations can be executed either sequentially or in parallel.

2. Stream operations (can be classified into two categories)
  they are called "intermediate operations" and "terminal operations"
  intermediate operations don't perform any processing until a terminal operation is invoked on the stream pipeline -- they are lazy
 2.1 Intermediate operations
   2.1.1 filter:
           return type: Steam<T>
           argument operation: Predicate<T>, function descriptor: T -> boolean
           description:
             takes a lambda to filter the source,
             only elements satisfying the filter condition are let through
   2.1.2 map:
           return type: Stream<R>
           argument operation: Function<T, R>, function descriptor: T -> R
           description:
             takes a lambda to operate on the source
             transform each element into another one or to extract information
 2.1.3 limit:
           return type: Stream<T>
           description:
           takes an integer
           truncate a stream to contain no more than the given number of elements
 2.1.4 sorted:
           return type: Stream<T>
           argument operation: Comparator<T>, function descriptor: (T, T) -> int
           description:
             sort the elements in stream according to the Comparator
 2.1.5 distinct
           return type: Stream<T>

 2.2Terminal Operations
   2.2.1 collect:
           converts a stream into another form.
   2.2.2 forEach:
           returns void and applies a lambda to each element in the source
   2.2.3 count:
           returns the number of elements in the output stream

3. comparison of collections and streams
   the difference between collections and streams has to do with when things are computed.
 3.1 collection
       is an in-memory data structure,
       every element in the collection has to be computed before it can be added to the collection.
       (in management speak, this is eagerly constructed, supplier-driven manufacturing)
 3.2 stream is a conceptually fixed data structure.
     which you can not add/remove elements from.
     elements in stream are computed on demand.
     Also stream can be viewed as a lazily constructed collection:
     values are computed when they're solicited by a consumer
     (in management speak, this is demand-driven, or even just-in-time manufacturing)

4. Traversable only once:
   for one created stream, it can traversed only once.
   if you want to traverse it a second time,
   you have to construct the stream again (if possible)

5. stream operations' loop fusion:
   multiple operations are merged into the same pass,
   whose effect is called "short-circuiting",
   which reduces the computational complexity

6. working with streams conforms the "builder pattern"
  components of working with streams:
 6.1 a data-source (such as a collection) to perform a query on
 6.2 a chain of intermediate operations that form a stream pipeline
 6.3 a terminal operation that executes the stream pipeline and produce a result

Working with streams
1. Filtering and Slicing
  1.1 filtering with a predicate
  1.2 filtering all unique elements in a stream by using "distinct()"
  1.3 truncating a stream to allow only N elements at the beginning pass by using "limit(N)"
  1.4 skipping N elements at the beginning by using "skip(N)",
      if the stream has fewer element than N,
      then an empty stream is returned.
      Note: limit(N) and skip(N) are complementary

2. Mapping
  2.1 map(Function<T,R> f),
        it applies the input function to each elements in the stream,
        mapping it into a new element
  2.2 flatMap(Function<T,Stream<R>> f),
        lets you replace each value of a stream with another stream,
        then concatenates all the generated streams into a single stream
        Note: "flat" means break the "outer structure" of each stream element

3. Finding and Matching
  3.1 anyMatch(Predicate<T> p),
        checking to see if a predicate matches at least one element in the stream
  3.2 allMatch(Predicate<T> p),
        checking to see if a predicate matches all elements in the stream
  3.3 noneMatch(Predicate<T> p),
        checking to see if a predicate matches none of the elements in the stream
  3.4 findAny(),
        returns an arbitrary element of the current stream.
        return type is Optional<T>
  3.5 findFirst(),
        returns the first element of a stream,
        it has more constraint than findAny() in parallelism

4. Optional<T> in a nutshell
  4.1 java.util.Optional is a "container" class to represent the existence or absence of a value
  4.2 Optional<T> force you to explicitly check for the presence of a value or deal with the absence of a value
    4.2.1 isPresent(),
            returns true if Optional contains a value
    4.2.2 isPresent(Consumer<T> block),
            executes the given block if a value is present
    4.2.3 T get(),
            returns the value if present,
            otherwise it throws a "NoSuchElement" exception,
            Note: the gist here is that it does not return null
    4.2.4 T orElse(T other),
            returns the value if present,
            otherwise returns a default value

5. Reducing
  5.1 Definition:

  5.2 reduce takes two arguments:
    5.2.1 an initial value
    5.2.2 a BinaryOperator<T> to combine two elements and produce a new value
    Note: the lambda supplied as the BinaryOperator<T> combines each element repeatedly
          until the stream is reduced to a single value.
  5.3 There is also an overloaded variant of reduce that doesn't take an initial value,
      but it returns an Optional Object
  5.4 map-reduce pattern:
        a chain of map() and reduce().

6. collect stream operation
    takes functional interface Collector<T, A, R> as input parameter

7. Stateful and Stateless operations
  7.1 Stateless operations:
        operations that do not have an internal state
        Note: stateless operations does not require memorization, thus has no pressure on memory
        e.g. "map", "filter"
  7.2 Stateful operations:
        operations that maintain an internal state:
        Note: stateful operations require memorization, thus can pose pressure on memory
        e.g. "reduce", "sum", "max", "sorted", "distinct"

8. Numeric streams
  8.1 Java 8 introduces three primitive specialized stream interfaces
    8.1.1 IntStream
    8.1.2 DoubleStream
    8.1.3 LongStream
    They respectively specialize the elements of a stream to be int, long, and double
    and thereby avoid hidden boxing costs
  8.2 Mapping to a numeric stream
    The most common methods you will use to convert a stream to a specialized version are
      mapToInt, mapToDouble, mapToLong
  8.3 IntStream interface,
        defines: sum, max, min, average, etc methods to manipulate raw int data
  8.4 converting back to a stream of objects
        call the "boxed()" method defined on the numeric streams
  8.5 Numeric Ranges
      call IntStream, LongStream's "range()" and "rangeClosed()" methods

9. Building Streams
  9.1 Streams from explicit values:
        Stream.of(values)
        Stream.empty()
  9.2 Streams from arrays
        Arrays.stream(arrayVariable)
  9.3 Streams from files
        java.nio.file.Files has many methods that can return a stream
  9.4 streams from functions: creating infinite streams
        Stream.iterate(T initValue, UnaryOperator<T> o), fundamentally sequential, because the next value's calculation is based on the current value
        Stream.generate(), unlike iterate(Supplier<T> s), it is not sequential
      Note: it is generally sensible to use limit(n) on such streams to avoid printing an infinite number of values
            also you can not "sort", "reduce" an infinite stream

Collecting data with streams
1. Reducing and summarizing stream elements to a single value
  1.1 collect vs reduce
    1.1.1 Semantic difference
      1.1.1.1 reduce:
                      meant to combine two values and produce a new one,
                      it is an immutable reduction
      1.1.1.2 collect:
                      meant to mutate a container to accumulate the result it is supposed to produce
    1.1.2 Practical difference
      1.1.2.1 reduce:
                      can not work in parallel,
                      because the concurrent modification of the same data structure operated by multiple threads can corrupt the collection
      1.1.2.2 collect:
                      cam work in parallel

  1.2 "?" generic wildcard:
        this can be used in a place which requires generic type,
        indicating the type is unknown (or can be any type)

2. Grouping elements
  2.1 classification: use groupingBy(CRITERIA_LAMBDA)

  2.2 Multi-level grouping use nested groupingBy:
        groupingBy(level1_key, groupingBy(level2_key, CRITERIA_LAMBDA))
      The return type is Map<level1_key, Map<level2_key, item>>
      Note:
        n-level nested map is equal to n-dimensional classification table
        it helps to think that groupingBy works in terms of "buckets"

  2.3 adapting the collector result to a different type:
        use Collectors.collectingAndThen(WrappedCollector, TransformationFunction)

  2.4 use toSet(), I can not have control over which type of Set will be created, however,
      use toCollection(HashSet::new), for example, I can generate a specific type of set (e.g. HashSet)

3. Partitioning elements
  3.1 partitioning is a special case of grouping,
      which only have two keys: true/false

4. The static factory methods of Collectors class
  4.1 Factory Method: toList
      Return Type: List<T>
      Used To: Gather all the stream's items in a List
      Example: List<Dish> dishes = menuSteam.collect(toList());

  4.2 Factory Method: toSet
      Return Type: Set<T>
      Used To: Gather all the stream's items in a Set, eliminating duplicates
      Example: Set<T> dishes = menuStream.collect(toSet());

  4.3 Factory Method: toCollection
      Return Type: Collection<T>
      Used To: Gather all the stream's items in the collection created by the provided suppler
      Example: Collection<Dish> dishes = menuStream.collect(toCollection(), ArrayList::new);

  4.4 Factory Method: counting
      Return Type: Long
      Used To: Count the number of items in the stream
      Example: long howManyDishes = menuStream.collect(counting());

  4.5 Factory Method: summingInt
      Return Type: Integer
      Used To: Sum the values of an Integer property of the items in the stream
      Example: int totalCalories = menuStream.collect(summingInt(Dish::getCalories));

  4.6 Factory Method: averagingInt
      Return Type: Double
      Used To: Calculate the average value of an Integer property of the items in the stream
      Example: double avgCalories = menuStream.collect(averagingInt(Dish::getCalories));

  4.7 Factory Method: summarizingInt
      Return Type: IntSummary-Statistics
      Used To: Collect statistics regarding an Integer property of the items in the stream,
               such as maximum, minimum, total, average
      Example: IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));

  4.8 Factory Method: joining
      Return Type: String
      Used To: Concatenate the strings resulting from the invocation of the toString method on each item of the stream
      Example: String shortMenu = menuStream.map(Dish::getName).collect(joining(","));

  4.9 Factory Method: maxBy
      Return Type: Optional<T>
      Used To: An Optional wrapping the maximal element in this stream according to the given comparator or Optional.empty() if the stream is empty
      Example: Optional<Dish> fattest = menuStream.collect(maxBy(comparingInt(Dish::getCalories)));

  4.10 Factory Method: minBy
       Return Type: Optional<T>
       Used To: An Optional wrapping the minimal element in this stream according to the given comparator or Optional.empty() if the stream is empty
       Example: Optional<Dish> lightest = menuStream.collect(minBy(comparingInt(Dish::getCalories)));

  4.11 Factory Method: reducing
       Return Type: The type produced by the reduction operation
       Used To: reduce the stream to a single value starting from an initial value used as accumulator
                and iteratively combining it with each item of the stream using a BinaryOperator
       Example: int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));

  4.12 Factory Method: collectingAndThen
       Return Type: the type returned by the transforming function
       Used To: wrap another collector and apply a transformation function to its result
       Example: int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size));

  4.13 Factory Method: groupingBy
       Return Type: Map<K, List<T>>
       Used To: Group the items in the stream based on the value of one of their properties and use those values as keys in the resulting Map
       Example: Map<Dish.Type, List<Dish>> dishByType = menuStream.collect(groupingBy(Dish::getType));

  4.14 Factory Method: partitioningBy
       Return Type: Map<Boolean, List<T>>
       Used To: partition the items in the stream based on the result of the application of a predicate to each of them.
       Example: Map<Boolean, List<Dish>> vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian));

5. 
